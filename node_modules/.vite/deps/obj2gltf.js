import {
  require_lib,
  require_path
} from "./chunk-NDJKX7H3.js";
import {
  require_buffer,
  require_png
} from "./chunk-IDAVXAMF.js";
import "./chunk-OJW2ONWQ.js";
import "./chunk-2SQCP5CH.js";
import {
  require_jpeg_js
} from "./chunk-V5M622HT.js";
import {
  require_mime
} from "./chunk-LQ4LBW5C.js";
import {
  require_bluebird
} from "./chunk-P3ZNIKUG.js";
import {
  __commonJS,
  __require
} from "./chunk-WNKWOKNR.js";

// node_modules/cesium/index.cjs
var require_cesium = __commonJS({
  "node_modules/cesium/index.cjs"(exports, module) {
    "use strict";
    var path = require_path();
    if (false) {
      module.exports = __require(path.join(__dirname, "Build/Cesium/index.cjs"));
      return;
    }
    module.exports = __require(path.join(
      __dirname,
      "Build/CesiumUnminified/index.cjs"
    ));
  }
});

// node_modules/obj2gltf/lib/getBufferPadded.js
var require_getBufferPadded = __commonJS({
  "node_modules/obj2gltf/lib/getBufferPadded.js"(exports, module) {
    "use strict";
    module.exports = getBufferPadded;
    function getBufferPadded(buffer) {
      const boundary = 4;
      const byteLength = buffer.length;
      const remainder = byteLength % boundary;
      if (remainder === 0) {
        return buffer;
      }
      const padding = remainder === 0 ? 0 : boundary - remainder;
      const emptyBuffer = Buffer.alloc(padding);
      return Buffer.concat([buffer, emptyBuffer]);
    }
  }
});

// node_modules/obj2gltf/lib/Texture.js
var require_Texture = __commonJS({
  "node_modules/obj2gltf/lib/Texture.js"(exports, module) {
    "use strict";
    module.exports = Texture;
    function Texture() {
      this.transparent = false;
      this.source = void 0;
      this.name = void 0;
      this.extension = void 0;
      this.path = void 0;
      this.pixels = void 0;
      this.width = void 0;
      this.height = void 0;
    }
  }
});

// node_modules/obj2gltf/lib/loadTexture.js
var require_loadTexture = __commonJS({
  "node_modules/obj2gltf/lib/loadTexture.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var fsExtra = require_lib();
    var jpeg = require_jpeg_js();
    var path = require_path();
    var PNG = require_png().PNG;
    var Promise2 = require_bluebird();
    var Texture = require_Texture();
    var defaultValue = Cesium.defaultValue;
    var defined = Cesium.defined;
    module.exports = loadTexture;
    function loadTexture(texturePath, options) {
      options = defaultValue(options, {});
      options.checkTransparency = defaultValue(options.checkTransparency, false);
      options.decode = defaultValue(options.decode, false);
      options.keepSource = defaultValue(options.keepSource, false);
      return fsExtra.readFile(texturePath).then(function(source) {
        const name = path.basename(texturePath, path.extname(texturePath));
        const extension = path.extname(texturePath).toLowerCase();
        const texture = new Texture();
        texture.source = source;
        texture.name = name;
        texture.extension = extension;
        texture.path = texturePath;
        let decodePromise;
        if (extension === ".png") {
          decodePromise = decodePng(texture, options);
        } else if (extension === ".jpg" || extension === ".jpeg") {
          decodePromise = decodeJpeg(texture, options);
        }
        if (defined(decodePromise)) {
          return decodePromise.then(function() {
            return texture;
          });
        }
        return texture;
      });
    }
    function hasTransparency(pixels) {
      const pixelsLength = pixels.length / 4;
      for (let i = 0; i < pixelsLength; ++i) {
        if (pixels[i * 4 + 3] < 255) {
          return true;
        }
      }
      return false;
    }
    function getChannels(colorType) {
      switch (colorType) {
        case 0:
          return 1;
        case 2:
          return 3;
        case 4:
          return 2;
        case 6:
          return 4;
        default:
          return 3;
      }
    }
    function parsePng(data) {
      return new Promise2(function(resolve, reject) {
        new PNG().parse(data, function(error, decodedResults) {
          if (defined(error)) {
            reject(error);
            return;
          }
          resolve(decodedResults);
        });
      });
    }
    function decodePng(texture, options) {
      const source = texture.source;
      const colorType = source[25];
      const channels = getChannels(colorType);
      const checkTransparency = channels === 4 && options.checkTransparency;
      const decode = options.decode || checkTransparency;
      if (decode) {
        return parsePng(source).then(function(decodedResults) {
          if (options.checkTransparency) {
            texture.transparent = hasTransparency(decodedResults.data);
          }
          if (options.decode) {
            texture.pixels = decodedResults.data;
            texture.width = decodedResults.width;
            texture.height = decodedResults.height;
            if (!options.keepSource) {
              texture.source = void 0;
            }
          }
        });
      }
    }
    function decodeJpeg(texture, options) {
      if (options.decode) {
        const source = texture.source;
        const decodedResults = jpeg.decode(source);
        texture.pixels = decodedResults.data;
        texture.width = decodedResults.width;
        texture.height = decodedResults.height;
        if (!options.keepSource) {
          texture.source = void 0;
        }
      }
    }
  }
});

// node_modules/obj2gltf/lib/outsideDirectory.js
var require_outsideDirectory = __commonJS({
  "node_modules/obj2gltf/lib/outsideDirectory.js"(exports, module) {
    "use strict";
    var path = require_path();
    module.exports = outsideDirectory;
    function outsideDirectory(file, directory) {
      return path.relative(directory, file).indexOf("..") === 0;
    }
  }
});

// browser-external:readline
var require_readline = __commonJS({
  "browser-external:readline"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "readline" has been externalized for browser compatibility. Cannot access "readline.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/obj2gltf/lib/readLines.js
var require_readLines = __commonJS({
  "node_modules/obj2gltf/lib/readLines.js"(exports, module) {
    "use strict";
    var fsExtra = require_lib();
    var Promise2 = require_bluebird();
    var readline = require_readline();
    var events = require_events();
    module.exports = readLines;
    function readLines(path, callback) {
      const stream = fsExtra.createReadStream(path);
      return events.once(stream, "open").then(function() {
        return new Promise2(function(resolve, reject) {
          stream.on("error", reject);
          stream.on("end", resolve);
          const lineReader = readline.createInterface({
            input: stream
          });
          const callbackWrapper = function(line) {
            try {
              callback(line);
            } catch (error) {
              reject(error);
            }
          };
          lineReader.on("line", callbackWrapper);
        });
      });
    }
  }
});

// node_modules/obj2gltf/lib/loadMtl.js
var require_loadMtl = __commonJS({
  "node_modules/obj2gltf/lib/loadMtl.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var path = require_path();
    var Promise2 = require_bluebird();
    var loadTexture = require_loadTexture();
    var outsideDirectory = require_outsideDirectory();
    var readLines = require_readLines();
    var Texture = require_Texture();
    var CesiumMath = Cesium.Math;
    var clone = Cesium.clone;
    var combine = Cesium.combine;
    var defaultValue = Cesium.defaultValue;
    var defined = Cesium.defined;
    module.exports = loadMtl;
    function loadMtl(mtlPath, options) {
      let material;
      let values;
      let value;
      const mtlDirectory = path.dirname(mtlPath);
      const materials = [];
      const texturePromiseMap = {};
      const texturePromises = [];
      const overridingTextures = options.overridingTextures;
      const overridingSpecularTexture = defaultValue(
        overridingTextures.metallicRoughnessOcclusionTexture,
        overridingTextures.specularGlossinessTexture
      );
      const overridingSpecularShininessTexture = defaultValue(
        overridingTextures.metallicRoughnessOcclusionTexture,
        overridingTextures.specularGlossinessTexture
      );
      const overridingAmbientTexture = defaultValue(
        overridingTextures.metallicRoughnessOcclusionTexture,
        overridingTextures.occlusionTexture
      );
      const overridingNormalTexture = overridingTextures.normalTexture;
      const overridingDiffuseTexture = overridingTextures.baseColorTexture;
      const overridingEmissiveTexture = overridingTextures.emissiveTexture;
      const overridingAlphaTexture = overridingTextures.alphaTexture;
      const decodeOptions = {
        decode: true
      };
      const diffuseTextureOptions = {
        checkTransparency: options.checkTransparency
      };
      const ambientTextureOptions = defined(overridingAmbientTexture) ? void 0 : options.packOcclusion ? decodeOptions : void 0;
      const specularTextureOptions = defined(overridingSpecularTexture) ? void 0 : decodeOptions;
      const specularShinessTextureOptions = defined(
        overridingSpecularShininessTexture
      ) ? void 0 : decodeOptions;
      const emissiveTextureOptions = void 0;
      const normalTextureOptions = void 0;
      const alphaTextureOptions = {
        decode: true
      };
      function createMaterial(name) {
        material = new Material();
        material.name = name;
        material.specularShininess = options.metallicRoughness ? 1 : 0;
        material.specularTexture = overridingSpecularTexture;
        material.specularShininessTexture = overridingSpecularShininessTexture;
        material.diffuseTexture = overridingDiffuseTexture;
        material.ambientTexture = overridingAmbientTexture;
        material.normalTexture = overridingNormalTexture;
        material.emissiveTexture = overridingEmissiveTexture;
        material.alphaTexture = overridingAlphaTexture;
        materials.push(material);
      }
      function normalizeTexturePath(texturePath, mtlDirectory2) {
        const re = /-(bm|t|s|o|blendu|blendv|boost|mm|texres|clamp|imfchan|type)/;
        if (re.test(texturePath)) {
          texturePath = texturePath.split(/\s+/).pop();
        }
        texturePath = texturePath.replace(/\\/g, "/");
        return path.normalize(path.resolve(mtlDirectory2, texturePath));
      }
      function parseLine(line) {
        line = line.trim();
        if (/^newmtl/i.test(line)) {
          const name = line.substring(7).trim();
          createMaterial(name);
        } else if (/^Ka /i.test(line)) {
          values = line.substring(3).trim().split(" ");
          material.ambientColor = [
            parseFloat(values[0]),
            parseFloat(values[1]),
            parseFloat(values[2]),
            1
          ];
        } else if (/^Ke /i.test(line)) {
          values = line.substring(3).trim().split(" ");
          material.emissiveColor = [
            parseFloat(values[0]),
            parseFloat(values[1]),
            parseFloat(values[2]),
            1
          ];
        } else if (/^Kd /i.test(line)) {
          values = line.substring(3).trim().split(" ");
          material.diffuseColor = [
            parseFloat(values[0]),
            parseFloat(values[1]),
            parseFloat(values[2]),
            1
          ];
        } else if (/^Ks /i.test(line)) {
          values = line.substring(3).trim().split(" ");
          material.specularColor = [
            parseFloat(values[0]),
            parseFloat(values[1]),
            parseFloat(values[2]),
            1
          ];
        } else if (/^Ns /i.test(line)) {
          value = line.substring(3).trim();
          material.specularShininess = parseFloat(value);
        } else if (/^d /i.test(line)) {
          value = line.substring(2).trim();
          material.alpha = correctAlpha(parseFloat(value));
        } else if (/^Tr /i.test(line)) {
          value = line.substring(3).trim();
          material.alpha = correctAlpha(1 - parseFloat(value));
        } else if (/^map_Ka /i.test(line)) {
          if (!defined(overridingAmbientTexture)) {
            material.ambientTexture = normalizeTexturePath(
              line.substring(7).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_Ke /i.test(line)) {
          if (!defined(overridingEmissiveTexture)) {
            material.emissiveTexture = normalizeTexturePath(
              line.substring(7).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_Kd /i.test(line)) {
          if (!defined(overridingDiffuseTexture)) {
            material.diffuseTexture = normalizeTexturePath(
              line.substring(7).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_Ks /i.test(line)) {
          if (!defined(overridingSpecularTexture)) {
            material.specularTexture = normalizeTexturePath(
              line.substring(7).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_Ns /i.test(line)) {
          if (!defined(overridingSpecularShininessTexture)) {
            material.specularShininessTexture = normalizeTexturePath(
              line.substring(7).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_Bump /i.test(line)) {
          if (!defined(overridingNormalTexture)) {
            material.normalTexture = normalizeTexturePath(
              line.substring(9).trim(),
              mtlDirectory
            );
          }
        } else if (/^map_d /i.test(line)) {
          if (!defined(overridingAlphaTexture)) {
            material.alphaTexture = normalizeTexturePath(
              line.substring(6).trim(),
              mtlDirectory
            );
          }
        }
      }
      function loadMaterialTextures(material2) {
        const diffuseAlphaTextureOptions = defined(material2.alphaTexture) ? alphaTextureOptions : diffuseTextureOptions;
        if (material2.diffuseTexture === material2.ambientTexture) {
          material2.ambientTexture = void 0;
        }
        const textureNames = [
          "diffuseTexture",
          "ambientTexture",
          "emissiveTexture",
          "specularTexture",
          "specularShininessTexture",
          "normalTexture",
          "alphaTexture"
        ];
        const textureOptions = [
          diffuseAlphaTextureOptions,
          ambientTextureOptions,
          emissiveTextureOptions,
          specularTextureOptions,
          specularShinessTextureOptions,
          normalTextureOptions,
          alphaTextureOptions
        ];
        const sharedOptions = {};
        textureNames.forEach(function(name, index) {
          const texturePath = material2[name];
          const originalOptions = textureOptions[index];
          if (defined(texturePath) && defined(originalOptions)) {
            if (!defined(sharedOptions[texturePath])) {
              sharedOptions[texturePath] = clone(originalOptions);
            }
            const options2 = sharedOptions[texturePath];
            options2.checkTransparency = options2.checkTransparency || originalOptions.checkTransparency;
            options2.decode = options2.decode || originalOptions.decode;
            options2.keepSource = options2.keepSource || !originalOptions.decode || !originalOptions.checkTransparency;
          }
        });
        textureNames.forEach(function(name) {
          const texturePath = material2[name];
          if (defined(texturePath)) {
            loadMaterialTexture(
              material2,
              name,
              sharedOptions[texturePath],
              mtlDirectory,
              texturePromiseMap,
              texturePromises,
              options
            );
          }
        });
      }
      return readLines(mtlPath, parseLine).then(function() {
        const length = materials.length;
        for (let i = 0; i < length; ++i) {
          loadMaterialTextures(materials[i]);
        }
        return Promise2.all(texturePromises);
      }).then(function() {
        return convertMaterials(materials, options);
      });
    }
    function correctAlpha(alpha) {
      return alpha === 0 ? 1 : alpha;
    }
    function Material() {
      this.name = void 0;
      this.ambientColor = [0, 0, 0, 1];
      this.emissiveColor = [0, 0, 0, 1];
      this.diffuseColor = [0.5, 0.5, 0.5, 1];
      this.specularColor = [0, 0, 0, 1];
      this.specularShininess = 0;
      this.alpha = 1;
      this.ambientTexture = void 0;
      this.emissiveTexture = void 0;
      this.diffuseTexture = void 0;
      this.specularTexture = void 0;
      this.specularShininessTexture = void 0;
      this.normalTexture = void 0;
      this.alphaTexture = void 0;
    }
    loadMtl.getDefaultMaterial = function(options) {
      return convertMaterial(new Material(), options);
    };
    loadMtl._createMaterial = function(materialOptions, options) {
      return convertMaterial(combine(materialOptions, new Material()), options);
    };
    function loadMaterialTexture(material, name, textureOptions, mtlDirectory, texturePromiseMap, texturePromises, options) {
      const texturePath = material[name];
      if (!defined(texturePath)) {
        return;
      }
      let texturePromise = texturePromiseMap[texturePath];
      if (!defined(texturePromise)) {
        const shallowPath = path.join(mtlDirectory, path.basename(texturePath));
        if (options.secure && outsideDirectory(texturePath, mtlDirectory)) {
          options.logger(
            "Texture file is outside of the mtl directory and the secure flag is true. Attempting to read the texture file from within the obj directory instead."
          );
          texturePromise = loadTexture(shallowPath, textureOptions).catch(function(error) {
            options.logger(error.message);
            options.logger(
              `Could not read texture file at ${shallowPath}. This texture will be ignored`
            );
          });
        } else {
          texturePromise = loadTexture(texturePath, textureOptions).catch(function(error) {
            options.logger(error.message);
            options.logger(
              `Could not read texture file at ${texturePath}. Attempting to read the texture file from within the obj directory instead.`
            );
            return loadTexture(shallowPath, textureOptions);
          }).catch(function(error) {
            options.logger(error.message);
            options.logger(
              `Could not read texture file at ${shallowPath}. This texture will be ignored.`
            );
          });
        }
        texturePromiseMap[texturePath] = texturePromise;
      }
      texturePromises.push(
        texturePromise.then(function(texture) {
          material[name] = texture;
        })
      );
    }
    function convertMaterial(material, options) {
      if (options.specularGlossiness) {
        return createSpecularGlossinessMaterial(material, options);
      } else if (options.metallicRoughness) {
        return createMetallicRoughnessMaterial(material, options);
      }
      convertTraditionalToMetallicRoughness(material);
      return createMetallicRoughnessMaterial(material, options);
    }
    function convertMaterials(materials, options) {
      return materials.map(function(material) {
        return convertMaterial(material, options);
      });
    }
    function resizeChannel(sourcePixels, sourceWidth, sourceHeight, targetPixels, targetWidth, targetHeight) {
      const widthRatio = sourceWidth / targetWidth;
      const heightRatio = sourceHeight / targetHeight;
      for (let y = 0; y < targetHeight; ++y) {
        for (let x = 0; x < targetWidth; ++x) {
          const targetIndex = y * targetWidth + x;
          const sourceY = Math.round(y * heightRatio);
          const sourceX = Math.round(x * widthRatio);
          const sourceIndex = sourceY * sourceWidth + sourceX;
          const sourceValue = sourcePixels.readUInt8(sourceIndex);
          targetPixels.writeUInt8(sourceValue, targetIndex);
        }
      }
      return targetPixels;
    }
    var scratchResizeChannel;
    function getTextureChannel(texture, index, targetWidth, targetHeight, targetChannel) {
      const pixels = texture.pixels;
      const sourceWidth = texture.width;
      const sourceHeight = texture.height;
      const sourcePixelsLength = sourceWidth * sourceHeight;
      const targetPixelsLength = targetWidth * targetHeight;
      let sourceChannel = targetChannel;
      if (sourcePixelsLength > targetPixelsLength) {
        if (!defined(scratchResizeChannel) || sourcePixelsLength > scratchResizeChannel.length) {
          scratchResizeChannel = Buffer.alloc(sourcePixelsLength);
        }
        sourceChannel = scratchResizeChannel;
      }
      for (let i = 0; i < sourcePixelsLength; ++i) {
        const value = pixels.readUInt8(i * 4 + index);
        sourceChannel.writeUInt8(value, i);
      }
      if (sourcePixelsLength > targetPixelsLength) {
        resizeChannel(
          sourceChannel,
          sourceWidth,
          sourceHeight,
          targetChannel,
          targetWidth,
          targetHeight
        );
      }
      return targetChannel;
    }
    function writeChannel(pixels, channel, index) {
      const pixelsLength = pixels.length / 4;
      for (let i = 0; i < pixelsLength; ++i) {
        const value = channel.readUInt8(i);
        pixels.writeUInt8(value, i * 4 + index);
      }
    }
    function getMinimumDimensions(textures, options) {
      let width = Number.POSITIVE_INFINITY;
      let height = Number.POSITIVE_INFINITY;
      const length = textures.length;
      for (let i = 0; i < length; ++i) {
        const texture = textures[i];
        width = Math.min(texture.width, width);
        height = Math.min(texture.height, height);
      }
      for (let i = 0; i < length; ++i) {
        const texture = textures[i];
        if (texture.width !== width || texture.height !== height) {
          options.logger(
            `Texture ${texture.path} will be scaled from ${texture.width}x${texture.height} to ${width}x${height}.`
          );
        }
      }
      return [width, height];
    }
    function isChannelSingleColor(buffer) {
      const first = buffer.readUInt8(0);
      const length = buffer.length;
      for (let i = 1; i < length; ++i) {
        if (buffer[i] !== first) {
          return false;
        }
      }
      return true;
    }
    function createDiffuseAlphaTexture(diffuseTexture, alphaTexture, options) {
      const packDiffuse = defined(diffuseTexture);
      const packAlpha = defined(alphaTexture);
      if (!packDiffuse) {
        return void 0;
      }
      if (!packAlpha) {
        return diffuseTexture;
      }
      if (diffuseTexture === alphaTexture) {
        return diffuseTexture;
      }
      if (!defined(diffuseTexture.pixels) || !defined(alphaTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${diffuseTexture.path} or ${alphaTexture.path}. The material will be created without an alpha texture.`
        );
        return diffuseTexture;
      }
      const packedTextures = [diffuseTexture, alphaTexture];
      const dimensions = getMinimumDimensions(packedTextures, options);
      const width = dimensions[0];
      const height = dimensions[1];
      const pixelsLength = width * height;
      const pixels = Buffer.alloc(pixelsLength * 4, 255);
      const scratchChannel = Buffer.alloc(pixelsLength);
      const redChannel = getTextureChannel(
        diffuseTexture,
        0,
        width,
        height,
        scratchChannel
      );
      writeChannel(pixels, redChannel, 0);
      const greenChannel = getTextureChannel(
        diffuseTexture,
        1,
        width,
        height,
        scratchChannel
      );
      writeChannel(pixels, greenChannel, 1);
      const blueChannel = getTextureChannel(
        diffuseTexture,
        2,
        width,
        height,
        scratchChannel
      );
      writeChannel(pixels, blueChannel, 2);
      let alphaChannel = getTextureChannel(
        alphaTexture,
        3,
        width,
        height,
        scratchChannel
      );
      if (isChannelSingleColor(alphaChannel)) {
        alphaChannel = getTextureChannel(
          alphaTexture,
          0,
          width,
          height,
          scratchChannel
        );
      }
      writeChannel(pixels, alphaChannel, 3);
      const texture = new Texture();
      texture.name = diffuseTexture.name;
      texture.extension = ".png";
      texture.pixels = pixels;
      texture.width = width;
      texture.height = height;
      texture.transparent = true;
      return texture;
    }
    function createMetallicRoughnessTexture(metallicTexture, roughnessTexture, occlusionTexture, options) {
      if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {
        return metallicTexture;
      }
      const packMetallic = defined(metallicTexture);
      const packRoughness = defined(roughnessTexture);
      const packOcclusion = defined(occlusionTexture) && options.packOcclusion;
      if (!packMetallic && !packRoughness) {
        return void 0;
      }
      if (packMetallic && !defined(metallicTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${metallicTexture.path}. The material will be created without a metallicRoughness texture.`
        );
        return void 0;
      }
      if (packRoughness && !defined(roughnessTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${roughnessTexture.path}. The material will be created without a metallicRoughness texture.`
        );
        return void 0;
      }
      if (packOcclusion && !defined(occlusionTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${occlusionTexture.path}. The occlusion texture will not be packed in the metallicRoughness texture.`
        );
        return void 0;
      }
      const packedTextures = [
        metallicTexture,
        roughnessTexture,
        occlusionTexture
      ].filter(function(texture2) {
        return defined(texture2) && defined(texture2.pixels);
      });
      const dimensions = getMinimumDimensions(packedTextures, options);
      const width = dimensions[0];
      const height = dimensions[1];
      const pixelsLength = width * height;
      const pixels = Buffer.alloc(pixelsLength * 4, 255);
      const scratchChannel = Buffer.alloc(pixelsLength);
      if (packMetallic) {
        const metallicChannel = getTextureChannel(
          metallicTexture,
          0,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, metallicChannel, 2);
      }
      if (packRoughness) {
        const roughnessChannel = getTextureChannel(
          roughnessTexture,
          0,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, roughnessChannel, 1);
      }
      if (packOcclusion) {
        const occlusionChannel = getTextureChannel(
          occlusionTexture,
          0,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, occlusionChannel, 0);
      }
      const length = packedTextures.length;
      const names = new Array(length);
      for (let i = 0; i < length; ++i) {
        names[i] = packedTextures[i].name;
      }
      const name = names.join("_");
      const texture = new Texture();
      texture.name = name;
      texture.extension = ".png";
      texture.pixels = pixels;
      texture.width = width;
      texture.height = height;
      return texture;
    }
    function createSpecularGlossinessTexture(specularTexture, glossinessTexture, options) {
      if (defined(options.overridingTextures.specularGlossinessTexture)) {
        return specularTexture;
      }
      const packSpecular = defined(specularTexture);
      const packGlossiness = defined(glossinessTexture);
      if (!packSpecular && !packGlossiness) {
        return void 0;
      }
      if (packSpecular && !defined(specularTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${specularTexture.path}. The material will be created without a specularGlossiness texture.`
        );
        return void 0;
      }
      if (packGlossiness && !defined(glossinessTexture.pixels)) {
        options.logger(
          `Could not get decoded texture data for ${glossinessTexture.path}. The material will be created without a specularGlossiness texture.`
        );
        return void 0;
      }
      const packedTextures = [specularTexture, glossinessTexture].filter(function(texture2) {
        return defined(texture2) && defined(texture2.pixels);
      });
      const dimensions = getMinimumDimensions(packedTextures, options);
      const width = dimensions[0];
      const height = dimensions[1];
      const pixelsLength = width * height;
      const pixels = Buffer.alloc(pixelsLength * 4, 255);
      const scratchChannel = Buffer.alloc(pixelsLength);
      if (packSpecular) {
        const redChannel = getTextureChannel(
          specularTexture,
          0,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, redChannel, 0);
        const greenChannel = getTextureChannel(
          specularTexture,
          1,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, greenChannel, 1);
        const blueChannel = getTextureChannel(
          specularTexture,
          2,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, blueChannel, 2);
      }
      if (packGlossiness) {
        const glossinessChannel = getTextureChannel(
          glossinessTexture,
          0,
          width,
          height,
          scratchChannel
        );
        writeChannel(pixels, glossinessChannel, 3);
      }
      const length = packedTextures.length;
      const names = new Array(length);
      for (let i = 0; i < length; ++i) {
        names[i] = packedTextures[i].name;
      }
      const name = names.join("_");
      const texture = new Texture();
      texture.name = name;
      texture.extension = ".png";
      texture.pixels = pixels;
      texture.width = width;
      texture.height = height;
      return texture;
    }
    function createSpecularGlossinessMaterial(material, options) {
      const emissiveTexture = material.emissiveTexture;
      const normalTexture = material.normalTexture;
      const occlusionTexture = material.ambientTexture;
      const diffuseTexture = material.diffuseTexture;
      const alphaTexture = material.alphaTexture;
      const specularTexture = material.specularTexture;
      const glossinessTexture = material.specularShininessTexture;
      const specularGlossinessTexture = createSpecularGlossinessTexture(
        specularTexture,
        glossinessTexture,
        options
      );
      const diffuseAlphaTexture = createDiffuseAlphaTexture(
        diffuseTexture,
        alphaTexture,
        options
      );
      let emissiveFactor = material.emissiveColor.slice(0, 3);
      let diffuseFactor = material.diffuseColor;
      let specularFactor = material.specularColor.slice(0, 3);
      let glossinessFactor = material.specularShininess;
      if (defined(emissiveTexture)) {
        emissiveFactor = [1, 1, 1];
      }
      if (defined(diffuseTexture)) {
        diffuseFactor = [1, 1, 1, 1];
      }
      if (defined(specularTexture)) {
        specularFactor = [1, 1, 1];
      }
      if (defined(glossinessTexture)) {
        glossinessFactor = 1;
      }
      let transparent = false;
      if (defined(alphaTexture)) {
        transparent = true;
      } else {
        const alpha = material.alpha;
        diffuseFactor[3] = alpha;
        transparent = alpha < 1;
      }
      if (defined(diffuseTexture)) {
        transparent = transparent || diffuseTexture.transparent;
      }
      const doubleSided = transparent;
      const alphaMode = transparent ? "BLEND" : "OPAQUE";
      return {
        name: material.name,
        extensions: {
          KHR_materials_pbrSpecularGlossiness: {
            diffuseTexture: diffuseAlphaTexture,
            specularGlossinessTexture,
            diffuseFactor,
            specularFactor,
            glossinessFactor
          }
        },
        emissiveTexture,
        normalTexture,
        occlusionTexture,
        emissiveFactor,
        alphaMode,
        doubleSided
      };
    }
    function createMetallicRoughnessMaterial(material, options) {
      const emissiveTexture = material.emissiveTexture;
      const normalTexture = material.normalTexture;
      let occlusionTexture = material.ambientTexture;
      const baseColorTexture = material.diffuseTexture;
      const alphaTexture = material.alphaTexture;
      const metallicTexture = material.specularTexture;
      const roughnessTexture = material.specularShininessTexture;
      const metallicRoughnessTexture = createMetallicRoughnessTexture(
        metallicTexture,
        roughnessTexture,
        occlusionTexture,
        options
      );
      const diffuseAlphaTexture = createDiffuseAlphaTexture(
        baseColorTexture,
        alphaTexture,
        options
      );
      if (options.packOcclusion) {
        occlusionTexture = metallicRoughnessTexture;
      }
      let emissiveFactor = material.emissiveColor.slice(0, 3);
      let baseColorFactor = material.diffuseColor;
      let metallicFactor = material.specularColor[0];
      let roughnessFactor = material.specularShininess;
      if (defined(emissiveTexture)) {
        emissiveFactor = [1, 1, 1];
      }
      if (defined(baseColorTexture)) {
        baseColorFactor = [1, 1, 1, 1];
      }
      if (defined(metallicTexture)) {
        metallicFactor = 1;
      }
      if (defined(roughnessTexture)) {
        roughnessFactor = 1;
      }
      let transparent = false;
      if (defined(alphaTexture)) {
        transparent = true;
      } else {
        const alpha = material.alpha;
        baseColorFactor[3] = alpha;
        transparent = alpha < 1;
      }
      if (defined(baseColorTexture)) {
        transparent = transparent || baseColorTexture.transparent;
      }
      const doubleSided = transparent;
      const alphaMode = transparent ? "BLEND" : "OPAQUE";
      return {
        name: material.name,
        pbrMetallicRoughness: {
          baseColorTexture: diffuseAlphaTexture,
          metallicRoughnessTexture,
          baseColorFactor,
          metallicFactor,
          roughnessFactor
        },
        emissiveTexture,
        normalTexture,
        occlusionTexture,
        emissiveFactor,
        alphaMode,
        doubleSided
      };
    }
    function luminance(color) {
      return color[0] * 0.2125 + color[1] * 0.7154 + color[2] * 0.0721;
    }
    function convertTraditionalToMetallicRoughness(material) {
      const specularIntensity = luminance(material.specularColor);
      let roughnessFactor = material.specularShininess;
      roughnessFactor = roughnessFactor / 1e3;
      roughnessFactor = 1 - roughnessFactor;
      roughnessFactor = CesiumMath.clamp(roughnessFactor, 0, 1);
      if (specularIntensity < 0.1) {
        roughnessFactor *= 1 - specularIntensity;
      }
      const metallicFactor = 0;
      material.specularColor = [
        metallicFactor,
        metallicFactor,
        metallicFactor,
        1
      ];
      material.specularShininess = roughnessFactor;
    }
  }
});

// node_modules/obj2gltf/lib/createGltf.js
var require_createGltf = __commonJS({
  "node_modules/obj2gltf/lib/createGltf.js"(exports, module) {
    "use strict";
    var FS_WRITE_MAX_LENGTH = 2147479552;
    var BUFFER_MAX_LENGTH = require_buffer().constants.MAX_LENGTH;
    var BUFFER_MAX_BYTE_LENGTH = Math.min(FS_WRITE_MAX_LENGTH, BUFFER_MAX_LENGTH);
    var Cesium = require_cesium();
    var getBufferPadded = require_getBufferPadded();
    var getDefaultMaterial = require_loadMtl().getDefaultMaterial;
    var Texture = require_Texture();
    var defaultValue = Cesium.defaultValue;
    var defined = Cesium.defined;
    var WebGLConstants = Cesium.WebGLConstants;
    module.exports = createGltf;
    function createGltf(objData, options) {
      const nodes = objData.nodes;
      let materials = objData.materials;
      const name = objData.name;
      materials = splitIncompatibleMaterials(nodes, materials, options);
      const gltf = {
        accessors: [],
        asset: {},
        buffers: [],
        bufferViews: [],
        extensionsUsed: [],
        extensionsRequired: [],
        images: [],
        materials: [],
        meshes: [],
        nodes: [],
        samplers: [],
        scene: 0,
        scenes: [],
        textures: []
      };
      gltf.asset = {
        generator: "obj2gltf",
        version: "2.0"
      };
      gltf.scenes.push({
        nodes: []
      });
      const bufferState = {
        positionBuffers: [],
        normalBuffers: [],
        uvBuffers: [],
        indexBuffers: [],
        positionAccessors: [],
        normalAccessors: [],
        uvAccessors: [],
        indexAccessors: []
      };
      const uint32Indices = requiresUint32Indices(nodes);
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const node = nodes[i];
        const meshes = node.meshes;
        const meshesLength = meshes.length;
        if (meshesLength === 1) {
          const meshIndex = addMesh(
            gltf,
            materials,
            bufferState,
            uint32Indices,
            meshes[0],
            options
          );
          addNode(gltf, node.name, meshIndex, void 0);
        } else {
          const parentIndex = addNode(gltf, node.name);
          for (let j = 0; j < meshesLength; ++j) {
            const mesh = meshes[j];
            const meshIndex = addMesh(
              gltf,
              materials,
              bufferState,
              uint32Indices,
              mesh,
              options
            );
            addNode(gltf, mesh.name, meshIndex, parentIndex);
          }
        }
      }
      if (gltf.images.length > 0) {
        gltf.samplers.push({
          wrapS: WebGLConstants.REPEAT,
          wrapT: WebGLConstants.REPEAT
        });
      }
      addBuffers(gltf, bufferState, name, options.separate);
      if (options.specularGlossiness) {
        gltf.extensionsUsed.push("KHR_materials_pbrSpecularGlossiness");
        gltf.extensionsRequired.push("KHR_materials_pbrSpecularGlossiness");
      }
      if (options.unlit) {
        gltf.extensionsUsed.push("KHR_materials_unlit");
        gltf.extensionsRequired.push("KHR_materials_unlit");
      }
      return gltf;
    }
    function addCombinedBufferView(gltf, buffers, accessors, byteStride, target) {
      const length = buffers.length;
      if (length === 0) {
        return;
      }
      const bufferViewIndex = gltf.bufferViews.length;
      const previousBufferView = gltf.bufferViews[bufferViewIndex - 1];
      const byteOffset = defined(previousBufferView) ? previousBufferView.byteOffset + previousBufferView.byteLength : 0;
      let byteLength = 0;
      for (let i = 0; i < length; ++i) {
        const accessor = gltf.accessors[accessors[i]];
        accessor.bufferView = bufferViewIndex;
        accessor.byteOffset = byteLength;
        byteLength += buffers[i].length;
      }
      gltf.bufferViews.push({
        name: `bufferView_${bufferViewIndex}`,
        buffer: 0,
        byteLength,
        byteOffset,
        byteStride,
        target
      });
    }
    function addCombinedBuffers(gltf, bufferState, name) {
      addCombinedBufferView(
        gltf,
        bufferState.positionBuffers,
        bufferState.positionAccessors,
        12,
        WebGLConstants.ARRAY_BUFFER
      );
      addCombinedBufferView(
        gltf,
        bufferState.normalBuffers,
        bufferState.normalAccessors,
        12,
        WebGLConstants.ARRAY_BUFFER
      );
      addCombinedBufferView(
        gltf,
        bufferState.uvBuffers,
        bufferState.uvAccessors,
        8,
        WebGLConstants.ARRAY_BUFFER
      );
      addCombinedBufferView(
        gltf,
        bufferState.indexBuffers,
        bufferState.indexAccessors,
        void 0,
        WebGLConstants.ELEMENT_ARRAY_BUFFER
      );
      let buffers = [];
      buffers = buffers.concat(
        bufferState.positionBuffers,
        bufferState.normalBuffers,
        bufferState.uvBuffers,
        bufferState.indexBuffers
      );
      const buffer = getBufferPadded(Buffer.concat(buffers));
      gltf.buffers.push({
        name,
        byteLength: buffer.length,
        extras: {
          _obj2gltf: {
            source: buffer
          }
        }
      });
    }
    function addSeparateBufferView(gltf, buffer, accessor, byteStride, target, name) {
      const bufferIndex = gltf.buffers.length;
      const bufferViewIndex = gltf.bufferViews.length;
      gltf.buffers.push({
        name: `${name}_${bufferIndex}`,
        byteLength: buffer.length,
        extras: {
          _obj2gltf: {
            source: buffer
          }
        }
      });
      gltf.bufferViews.push({
        buffer: bufferIndex,
        byteLength: buffer.length,
        byteOffset: 0,
        byteStride,
        target
      });
      gltf.accessors[accessor].bufferView = bufferViewIndex;
      gltf.accessors[accessor].byteOffset = 0;
    }
    function addSeparateBufferViews(gltf, buffers, accessors, byteStride, target, name) {
      const length = buffers.length;
      for (let i = 0; i < length; ++i) {
        addSeparateBufferView(
          gltf,
          buffers[i],
          accessors[i],
          byteStride,
          target,
          name
        );
      }
    }
    function addSeparateBuffers(gltf, bufferState, name) {
      addSeparateBufferViews(
        gltf,
        bufferState.positionBuffers,
        bufferState.positionAccessors,
        12,
        WebGLConstants.ARRAY_BUFFER,
        name
      );
      addSeparateBufferViews(
        gltf,
        bufferState.normalBuffers,
        bufferState.normalAccessors,
        12,
        WebGLConstants.ARRAY_BUFFER,
        name
      );
      addSeparateBufferViews(
        gltf,
        bufferState.uvBuffers,
        bufferState.uvAccessors,
        8,
        WebGLConstants.ARRAY_BUFFER,
        name
      );
      addSeparateBufferViews(
        gltf,
        bufferState.indexBuffers,
        bufferState.indexAccessors,
        void 0,
        WebGLConstants.ELEMENT_ARRAY_BUFFER,
        name
      );
    }
    function addBuffers(gltf, bufferState, name, separate) {
      const buffers = bufferState.positionBuffers.concat(
        bufferState.normalBuffers,
        bufferState.uvBuffers,
        bufferState.indexBuffers
      );
      const buffersLength = buffers.length;
      let buffersByteLength = 0;
      for (let i = 0; i < buffersLength; ++i) {
        buffersByteLength += buffers[i].length;
      }
      if (separate && buffersByteLength > createGltf._getBufferMaxByteLength()) {
        addSeparateBuffers(gltf, bufferState, name);
      } else {
        addCombinedBuffers(gltf, bufferState, name);
      }
    }
    function addTexture(gltf, texture) {
      const imageName = texture.name;
      const textureName = texture.name;
      const imageIndex = gltf.images.length;
      const textureIndex = gltf.textures.length;
      gltf.images.push({
        name: imageName,
        extras: {
          _obj2gltf: texture
        }
      });
      gltf.textures.push({
        name: textureName,
        sampler: 0,
        source: imageIndex
      });
      return textureIndex;
    }
    function getTexture(gltf, texture) {
      let textureIndex;
      const images = gltf.images;
      const length = images.length;
      for (let i = 0; i < length; ++i) {
        if (images[i].extras._obj2gltf === texture) {
          textureIndex = i;
          break;
        }
      }
      if (!defined(textureIndex)) {
        textureIndex = addTexture(gltf, texture);
      }
      return {
        index: textureIndex
      };
    }
    function cloneMaterial(material, removeTextures) {
      if (typeof material !== "object") {
        return material;
      } else if (material instanceof Texture) {
        if (removeTextures) {
          return void 0;
        }
        return material;
      } else if (Array.isArray(material)) {
        const length = material.length;
        const clonedArray = new Array(length);
        for (let i = 0; i < length; ++i) {
          clonedArray[i] = cloneMaterial(material[i], removeTextures);
        }
        return clonedArray;
      }
      const clonedObject = {};
      for (const name in material) {
        if (Object.prototype.hasOwnProperty.call(material, name)) {
          clonedObject[name] = cloneMaterial(material[name], removeTextures);
        }
      }
      return clonedObject;
    }
    function resolveTextures(gltf, material) {
      for (const name in material) {
        if (Object.prototype.hasOwnProperty.call(material, name)) {
          const property = material[name];
          if (property instanceof Texture) {
            material[name] = getTexture(gltf, property);
          } else if (!Array.isArray(property) && typeof property === "object") {
            resolveTextures(gltf, property);
          }
        }
      }
    }
    function addGltfMaterial(gltf, material, options) {
      resolveTextures(gltf, material);
      const materialIndex = gltf.materials.length;
      if (options.unlit) {
        if (!defined(material.extensions)) {
          material.extensions = {};
        }
        material.extensions.KHR_materials_unlit = {};
      }
      gltf.materials.push(material);
      return materialIndex;
    }
    function getMaterialByName(materials, materialName) {
      const materialsLength = materials.length;
      for (let i = 0; i < materialsLength; ++i) {
        if (materials[i].name === materialName) {
          return materials[i];
        }
      }
    }
    function getMaterialIndex(materials, materialName) {
      const materialsLength = materials.length;
      for (let i = 0; i < materialsLength; ++i) {
        if (materials[i].name === materialName) {
          return i;
        }
      }
    }
    function getOrCreateGltfMaterial(gltf, materials, materialName, options) {
      const material = getMaterialByName(materials, materialName);
      let materialIndex = getMaterialIndex(gltf.materials, materialName);
      if (!defined(materialIndex)) {
        materialIndex = addGltfMaterial(gltf, material, options);
      }
      return materialIndex;
    }
    function primitiveInfoMatch(a, b) {
      return a.hasUvs === b.hasUvs && a.hasNormals === b.hasNormals;
    }
    function getSplitMaterialName(originalMaterialName, primitiveInfo, primitiveInfoByMaterial) {
      let splitMaterialName = originalMaterialName;
      let suffix = 2;
      while (defined(primitiveInfoByMaterial[splitMaterialName])) {
        if (primitiveInfoMatch(
          primitiveInfo,
          primitiveInfoByMaterial[splitMaterialName]
        )) {
          break;
        }
        splitMaterialName = `${originalMaterialName}-${suffix++}`;
      }
      return splitMaterialName;
    }
    function splitIncompatibleMaterials(nodes, materials, options) {
      const splitMaterials = [];
      const primitiveInfoByMaterial = {};
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const meshes = nodes[i].meshes;
        const meshesLength = meshes.length;
        for (let j = 0; j < meshesLength; ++j) {
          const primitives = meshes[j].primitives;
          const primitivesLength = primitives.length;
          for (let k = 0; k < primitivesLength; ++k) {
            const primitive = primitives[k];
            const hasUvs = primitive.uvs.length > 0;
            const hasNormals = primitive.normals.length > 0;
            const primitiveInfo = {
              hasUvs,
              hasNormals
            };
            const originalMaterialName = defaultValue(
              primitive.material,
              "default"
            );
            const splitMaterialName = getSplitMaterialName(
              originalMaterialName,
              primitiveInfo,
              primitiveInfoByMaterial
            );
            primitive.material = splitMaterialName;
            primitiveInfoByMaterial[splitMaterialName] = primitiveInfo;
            let splitMaterial = getMaterialByName(
              splitMaterials,
              splitMaterialName
            );
            if (defined(splitMaterial)) {
              continue;
            }
            const originalMaterial = getMaterialByName(
              materials,
              originalMaterialName
            );
            if (defined(originalMaterial)) {
              splitMaterial = cloneMaterial(originalMaterial, !hasUvs);
            } else {
              splitMaterial = getDefaultMaterial(options);
            }
            splitMaterial.name = splitMaterialName;
            splitMaterials.push(splitMaterial);
          }
        }
      }
      return splitMaterials;
    }
    function addVertexAttribute(gltf, array, components, name) {
      const count = array.length / components;
      const minMax = array.getMinMax(components);
      const type = components === 3 ? "VEC3" : "VEC2";
      const accessor = {
        name,
        componentType: WebGLConstants.FLOAT,
        count,
        min: minMax.min,
        max: minMax.max,
        type
      };
      const accessorIndex = gltf.accessors.length;
      gltf.accessors.push(accessor);
      return accessorIndex;
    }
    function addIndexArray(gltf, array, uint32Indices, name) {
      const componentType = uint32Indices ? WebGLConstants.UNSIGNED_INT : WebGLConstants.UNSIGNED_SHORT;
      const count = array.length;
      const minMax = array.getMinMax(1);
      const accessor = {
        name,
        componentType,
        count,
        min: minMax.min,
        max: minMax.max,
        type: "SCALAR"
      };
      const accessorIndex = gltf.accessors.length;
      gltf.accessors.push(accessor);
      return accessorIndex;
    }
    function requiresUint32Indices(nodes) {
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const meshes = nodes[i].meshes;
        const meshesLength = meshes.length;
        for (let j = 0; j < meshesLength; ++j) {
          const primitives = meshes[j].primitives;
          const primitivesLength = primitives.length;
          for (let k = 0; k < primitivesLength; ++k) {
            const vertexCount = primitives[k].positions.length / 3;
            if (vertexCount > 65534) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function addPrimitive(gltf, materials, bufferState, uint32Indices, mesh, primitive, index, options) {
      const hasPositions = primitive.positions.length > 0;
      const hasNormals = primitive.normals.length > 0;
      const hasUVs = primitive.uvs.length > 0;
      const attributes = {};
      if (hasPositions) {
        const accessorIndex = addVertexAttribute(
          gltf,
          primitive.positions,
          3,
          `${mesh.name}_${index}_positions`
        );
        attributes.POSITION = accessorIndex;
        bufferState.positionBuffers.push(primitive.positions.toFloatBuffer());
        bufferState.positionAccessors.push(accessorIndex);
      }
      if (hasNormals) {
        const accessorIndex = addVertexAttribute(
          gltf,
          primitive.normals,
          3,
          `${mesh.name}_${index}_normals`
        );
        attributes.NORMAL = accessorIndex;
        bufferState.normalBuffers.push(primitive.normals.toFloatBuffer());
        bufferState.normalAccessors.push(accessorIndex);
      }
      if (hasUVs) {
        const accessorIndex = addVertexAttribute(
          gltf,
          primitive.uvs,
          2,
          `${mesh.name}_${index}_texcoords`
        );
        attributes.TEXCOORD_0 = accessorIndex;
        bufferState.uvBuffers.push(primitive.uvs.toFloatBuffer());
        bufferState.uvAccessors.push(accessorIndex);
      }
      const indexAccessorIndex = addIndexArray(
        gltf,
        primitive.indices,
        uint32Indices,
        `${mesh.name}_${index}_indices`
      );
      const indexBuffer = uint32Indices ? primitive.indices.toUint32Buffer() : primitive.indices.toUint16Buffer();
      bufferState.indexBuffers.push(indexBuffer);
      bufferState.indexAccessors.push(indexAccessorIndex);
      primitive.positions = void 0;
      primitive.normals = void 0;
      primitive.uvs = void 0;
      primitive.indices = void 0;
      const materialIndex = getOrCreateGltfMaterial(
        gltf,
        materials,
        primitive.material,
        options
      );
      return {
        attributes,
        indices: indexAccessorIndex,
        material: materialIndex,
        mode: WebGLConstants.TRIANGLES
      };
    }
    function addMesh(gltf, materials, bufferState, uint32Indices, mesh, options) {
      const gltfPrimitives = [];
      const primitives = mesh.primitives;
      const primitivesLength = primitives.length;
      for (let i = 0; i < primitivesLength; ++i) {
        gltfPrimitives.push(
          addPrimitive(
            gltf,
            materials,
            bufferState,
            uint32Indices,
            mesh,
            primitives[i],
            i,
            options
          )
        );
      }
      const gltfMesh = {
        name: mesh.name,
        primitives: gltfPrimitives
      };
      const meshIndex = gltf.meshes.length;
      gltf.meshes.push(gltfMesh);
      return meshIndex;
    }
    function addNode(gltf, name, meshIndex, parentIndex) {
      const node = {
        name,
        mesh: meshIndex
      };
      const nodeIndex = gltf.nodes.length;
      gltf.nodes.push(node);
      if (defined(parentIndex)) {
        const parentNode = gltf.nodes[parentIndex];
        if (!defined(parentNode.children)) {
          parentNode.children = [];
        }
        parentNode.children.push(nodeIndex);
      } else {
        gltf.scenes[gltf.scene].nodes.push(nodeIndex);
      }
      return nodeIndex;
    }
    createGltf._getBufferMaxByteLength = function() {
      return BUFFER_MAX_BYTE_LENGTH;
    };
  }
});

// node_modules/obj2gltf/lib/ArrayStorage.js
var require_ArrayStorage = __commonJS({
  "node_modules/obj2gltf/lib/ArrayStorage.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var ComponentDatatype = Cesium.ComponentDatatype;
    module.exports = ArrayStorage;
    var initialLength = 1024;
    var doublingThreshold = 33554432;
    var fixedExpansionLength = 33554432;
    function ArrayStorage(componentDatatype) {
      this.componentDatatype = componentDatatype;
      this.typedArray = ComponentDatatype.createTypedArray(componentDatatype, 0);
      this.length = 0;
    }
    function resize(storage, length) {
      const typedArray = ComponentDatatype.createTypedArray(
        storage.componentDatatype,
        length
      );
      typedArray.set(storage.typedArray);
      storage.typedArray = typedArray;
    }
    ArrayStorage.prototype.push = function(value) {
      const length = this.length;
      const typedArrayLength = this.typedArray.length;
      if (length === 0) {
        resize(this, initialLength);
      } else if (length === typedArrayLength) {
        if (length < doublingThreshold) {
          resize(this, typedArrayLength * 2);
        } else {
          resize(this, typedArrayLength + fixedExpansionLength);
        }
      }
      this.typedArray[this.length++] = value;
    };
    ArrayStorage.prototype.get = function(index) {
      return this.typedArray[index];
    };
    var sizeOfUint16 = 2;
    var sizeOfUint32 = 4;
    var sizeOfFloat = 4;
    ArrayStorage.prototype.toUint16Buffer = function() {
      const length = this.length;
      const typedArray = this.typedArray;
      const paddedLength = length + (length % 2 === 0 ? 0 : 1);
      const buffer = Buffer.alloc(paddedLength * sizeOfUint16);
      for (let i = 0; i < length; ++i) {
        buffer.writeUInt16LE(typedArray[i], i * sizeOfUint16);
      }
      return buffer;
    };
    ArrayStorage.prototype.toUint32Buffer = function() {
      const length = this.length;
      const typedArray = this.typedArray;
      const buffer = Buffer.alloc(length * sizeOfUint32);
      for (let i = 0; i < length; ++i) {
        buffer.writeUInt32LE(typedArray[i], i * sizeOfUint32);
      }
      return buffer;
    };
    ArrayStorage.prototype.toFloatBuffer = function() {
      const length = this.length;
      const typedArray = this.typedArray;
      const buffer = Buffer.alloc(length * sizeOfFloat);
      for (let i = 0; i < length; ++i) {
        buffer.writeFloatLE(typedArray[i], i * sizeOfFloat);
      }
      return buffer;
    };
    ArrayStorage.prototype.getMinMax = function(components) {
      const length = this.length;
      const typedArray = this.typedArray;
      const count = length / components;
      const min = new Array(components).fill(Number.POSITIVE_INFINITY);
      const max = new Array(components).fill(Number.NEGATIVE_INFINITY);
      for (let i = 0; i < count; ++i) {
        for (let j = 0; j < components; ++j) {
          const index = i * components + j;
          const value = typedArray[index];
          min[j] = Math.min(min[j], value);
          max[j] = Math.max(max[j], value);
        }
      }
      return {
        min,
        max
      };
    };
  }
});

// node_modules/obj2gltf/lib/loadObj.js
var require_loadObj = __commonJS({
  "node_modules/obj2gltf/lib/loadObj.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var path = require_path();
    var Promise2 = require_bluebird();
    var ArrayStorage = require_ArrayStorage();
    var loadMtl = require_loadMtl();
    var outsideDirectory = require_outsideDirectory();
    var readLines = require_readLines();
    var Axis = Cesium.Axis;
    var Cartesian3 = Cesium.Cartesian3;
    var ComponentDatatype = Cesium.ComponentDatatype;
    var CoplanarPolygonGeometryLibrary = Cesium.CoplanarPolygonGeometryLibrary;
    var defaultValue = Cesium.defaultValue;
    var defined = Cesium.defined;
    var PolygonPipeline = Cesium.PolygonPipeline;
    var RuntimeError = Cesium.RuntimeError;
    var WindingOrder = Cesium.WindingOrder;
    var Matrix4 = Cesium.Matrix4;
    module.exports = loadObj;
    function Node() {
      this.name = void 0;
      this.meshes = [];
    }
    function Mesh() {
      this.name = void 0;
      this.primitives = [];
    }
    function Primitive() {
      this.material = void 0;
      this.indices = new ArrayStorage(ComponentDatatype.UNSIGNED_INT);
      this.positions = new ArrayStorage(ComponentDatatype.FLOAT);
      this.normals = new ArrayStorage(ComponentDatatype.FLOAT);
      this.uvs = new ArrayStorage(ComponentDatatype.FLOAT);
    }
    var vertexPattern = /v(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/;
    var normalPattern = /vn(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/;
    var uvPattern = /vt(\s+[\d|\.|\+|\-|e|E]+)(\s+[\d|\.|\+|\-|e|E]+)/;
    var facePattern = /(-?\d+)\/?(-?\d*)\/?(-?\d*)/g;
    var scratchCartesian = new Cartesian3();
    function loadObj(objPath, options) {
      const axisTransform = getAxisTransform(
        options.inputUpAxis,
        options.outputUpAxis
      );
      let globalPositions = new ArrayStorage(ComponentDatatype.FLOAT);
      let globalNormals = new ArrayStorage(ComponentDatatype.FLOAT);
      let globalUvs = new ArrayStorage(ComponentDatatype.FLOAT);
      let node;
      let mesh;
      let primitive;
      let activeMaterial;
      const nodes = [];
      let vertexCache = {};
      const vertexCacheLimit = 1e6;
      let vertexCacheCount = 0;
      let vertexCount = 0;
      let mtlPaths = [];
      let lineBuffer = "";
      const faceVertices = [];
      const facePositions = [];
      const faceUvs = [];
      const faceNormals = [];
      function clearVertexCache() {
        vertexCache = {};
        vertexCacheCount = 0;
      }
      function getName(name) {
        return name === "" ? void 0 : name;
      }
      function addNode(name) {
        node = new Node();
        node.name = getName(name);
        nodes.push(node);
        addMesh();
      }
      function addMesh(name) {
        mesh = new Mesh();
        mesh.name = getName(name);
        node.meshes.push(mesh);
        addPrimitive();
      }
      function addPrimitive() {
        primitive = new Primitive();
        primitive.material = activeMaterial;
        mesh.primitives.push(primitive);
        clearVertexCache();
        vertexCount = 0;
      }
      function reusePrimitive(callback) {
        const primitives = mesh.primitives;
        const primitivesLength = primitives.length;
        for (let i = 0; i < primitivesLength; ++i) {
          if (primitives[i].material === activeMaterial) {
            if (!defined(callback) || callback(primitives[i])) {
              primitive = primitives[i];
              clearVertexCache();
              vertexCount = primitive.positions.length / 3;
              return;
            }
          }
        }
        addPrimitive();
      }
      function useMaterial(name) {
        activeMaterial = getName(name);
        reusePrimitive();
      }
      function faceAndPrimitiveMatch(uvs, normals, primitive2) {
        const faceHasUvs = defined(uvs[0]);
        const faceHasNormals = defined(normals[0]);
        const primitiveHasUvs = primitive2.uvs.length > 0;
        const primitiveHasNormals = primitive2.normals.length > 0;
        return primitiveHasUvs === faceHasUvs && primitiveHasNormals === faceHasNormals;
      }
      function checkPrimitive(uvs, normals) {
        const firstFace = primitive.indices.length === 0;
        if (!firstFace && !faceAndPrimitiveMatch(uvs, normals, primitive)) {
          reusePrimitive(function(primitive2) {
            return faceAndPrimitiveMatch(uvs, normals, primitive2);
          });
        }
      }
      function getIndexFromStart(index, attributeData, components) {
        const i = parseInt(index);
        if (i < 0) {
          return attributeData.length / components + i;
        }
        return i - 1;
      }
      function correctAttributeIndices(attributeIndices, attributeData, components) {
        const length = attributeIndices.length;
        for (let i = 0; i < length; ++i) {
          if (attributeIndices[i].length === 0) {
            attributeIndices[i] = void 0;
          } else {
            attributeIndices[i] = getIndexFromStart(
              attributeIndices[i],
              attributeData,
              components
            );
          }
        }
      }
      function correctVertices(vertices, positions, uvs, normals) {
        const length = vertices.length;
        for (let i = 0; i < length; ++i) {
          vertices[i] = `${defaultValue(positions[i], "")}/${defaultValue(
            uvs[i],
            ""
          )}/${defaultValue(normals[i], "")}`;
        }
      }
      function createVertex(p, u, n) {
        if (defined(p) && globalPositions.length > 0) {
          if (p * 3 >= globalPositions.length) {
            throw new RuntimeError(`Position index ${p} is out of bounds`);
          }
          const px = globalPositions.get(p * 3);
          const py = globalPositions.get(p * 3 + 1);
          const pz = globalPositions.get(p * 3 + 2);
          primitive.positions.push(px);
          primitive.positions.push(py);
          primitive.positions.push(pz);
        }
        if (defined(n) && globalNormals.length > 0) {
          if (n * 3 >= globalNormals.length) {
            throw new RuntimeError(`Normal index ${n} is out of bounds`);
          }
          const nx = globalNormals.get(n * 3);
          const ny = globalNormals.get(n * 3 + 1);
          const nz = globalNormals.get(n * 3 + 2);
          primitive.normals.push(nx);
          primitive.normals.push(ny);
          primitive.normals.push(nz);
        }
        if (defined(u) && globalUvs.length > 0) {
          if (u * 2 >= globalUvs.length) {
            throw new RuntimeError(`UV index ${u} is out of bounds`);
          }
          const ux = globalUvs.get(u * 2);
          const uy = globalUvs.get(u * 2 + 1);
          primitive.uvs.push(ux);
          primitive.uvs.push(uy);
        }
      }
      function addVertex(v, p, u, n) {
        let index = vertexCache[v];
        if (!defined(index)) {
          index = vertexCount++;
          vertexCache[v] = index;
          createVertex(p, u, n);
          vertexCacheCount++;
          if (vertexCacheCount > vertexCacheLimit) {
            clearVertexCache();
          }
        }
        return index;
      }
      function getPosition(index, result) {
        const px = globalPositions.get(index * 3);
        const py = globalPositions.get(index * 3 + 1);
        const pz = globalPositions.get(index * 3 + 2);
        return Cartesian3.fromElements(px, py, pz, result);
      }
      function getNormal(index, result) {
        const nx = globalNormals.get(index * 3);
        const ny = globalNormals.get(index * 3 + 1);
        const nz = globalNormals.get(index * 3 + 2);
        return Cartesian3.fromElements(nx, ny, nz, result);
      }
      const scratch1 = new Cartesian3();
      const scratch2 = new Cartesian3();
      const scratch3 = new Cartesian3();
      const scratch4 = new Cartesian3();
      const scratch5 = new Cartesian3();
      const scratchCenter = new Cartesian3();
      const scratchAxis1 = new Cartesian3();
      const scratchAxis2 = new Cartesian3();
      const scratchNormal = new Cartesian3();
      const scratchPositions = [
        new Cartesian3(),
        new Cartesian3(),
        new Cartesian3(),
        new Cartesian3()
      ];
      const scratchVertexIndices = [];
      const scratchPoints = [];
      function checkWindingCorrect(positionIndex1, positionIndex2, positionIndex3, normalIndex) {
        if (!defined(normalIndex)) {
          return true;
        }
        const normal = getNormal(normalIndex, scratchNormal);
        const A = getPosition(positionIndex1, scratch1);
        const B = getPosition(positionIndex2, scratch2);
        const C = getPosition(positionIndex3, scratch3);
        const BA = Cartesian3.subtract(B, A, scratch4);
        const CA = Cartesian3.subtract(C, A, scratch5);
        const cross = Cartesian3.cross(BA, CA, scratch3);
        return Cartesian3.dot(normal, cross) >= 0;
      }
      function addTriangle(index1, index2, index3, correctWinding) {
        if (correctWinding) {
          primitive.indices.push(index1);
          primitive.indices.push(index2);
          primitive.indices.push(index3);
        } else {
          primitive.indices.push(index1);
          primitive.indices.push(index3);
          primitive.indices.push(index2);
        }
      }
      function addFace(vertices, positions, uvs, normals, triangleWindingOrderSanitization) {
        correctAttributeIndices(positions, globalPositions, 3);
        correctAttributeIndices(normals, globalNormals, 3);
        correctAttributeIndices(uvs, globalUvs, 2);
        correctVertices(vertices, positions, uvs, normals);
        checkPrimitive(uvs, faceNormals);
        if (vertices.length === 3) {
          const isWindingCorrect = !triangleWindingOrderSanitization || checkWindingCorrect(
            positions[0],
            positions[1],
            positions[2],
            normals[0]
          );
          const index1 = addVertex(vertices[0], positions[0], uvs[0], normals[0]);
          const index2 = addVertex(vertices[1], positions[1], uvs[1], normals[1]);
          const index3 = addVertex(vertices[2], positions[2], uvs[2], normals[2]);
          addTriangle(index1, index2, index3, isWindingCorrect);
        } else {
          const points = scratchPoints;
          const vertexIndices = scratchVertexIndices;
          points.length = 0;
          vertexIndices.length = 0;
          for (let i = 0; i < vertices.length; ++i) {
            const index = addVertex(vertices[i], positions[i], uvs[i], normals[i]);
            vertexIndices.push(index);
            if (i === scratchPositions.length) {
              scratchPositions.push(new Cartesian3());
            }
            points.push(getPosition(positions[i], scratchPositions[i]));
          }
          const validGeometry = CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(
            points,
            scratchCenter,
            scratchAxis1,
            scratchAxis2
          );
          if (!validGeometry) {
            return;
          }
          const projectPoints = CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(
            scratchCenter,
            scratchAxis1,
            scratchAxis2
          );
          const points2D = projectPoints(points);
          const indices = PolygonPipeline.triangulate(points2D);
          const isWindingCorrect = PolygonPipeline.computeWindingOrder2D(points2D) !== WindingOrder.CLOCKWISE;
          for (let i = 0; i < indices.length - 2; i += 3) {
            addTriangle(
              vertexIndices[indices[i]],
              vertexIndices[indices[i + 1]],
              vertexIndices[indices[i + 2]],
              isWindingCorrect
            );
          }
        }
      }
      function parseLine(line) {
        line = line.trim();
        let result;
        if (line.length === 0 || line.charAt(0) === "#") {
        } else if (/^o\s/i.test(line)) {
          const objectName = line.substring(2).trim();
          addNode(objectName);
        } else if (/^g\s/i.test(line)) {
          const groupName = line.substring(2).trim();
          addMesh(groupName);
        } else if (/^usemtl/i.test(line)) {
          const materialName = line.substring(7).trim();
          useMaterial(materialName);
        } else if (/^mtllib/i.test(line)) {
          const mtllibLine = line.substring(7).trim();
          mtlPaths = mtlPaths.concat(getMtlPaths(mtllibLine));
        } else if ((result = vertexPattern.exec(line)) !== null) {
          const position = scratchCartesian;
          position.x = parseFloat(result[1]);
          position.y = parseFloat(result[2]);
          position.z = parseFloat(result[3]);
          if (defined(axisTransform)) {
            Matrix4.multiplyByPoint(axisTransform, position, position);
          }
          globalPositions.push(position.x);
          globalPositions.push(position.y);
          globalPositions.push(position.z);
        } else if ((result = normalPattern.exec(line)) !== null) {
          const normal = Cartesian3.fromElements(
            parseFloat(result[1]),
            parseFloat(result[2]),
            parseFloat(result[3]),
            scratchNormal
          );
          if (Cartesian3.equals(normal, Cartesian3.ZERO)) {
            Cartesian3.clone(Cartesian3.UNIT_Z, normal);
          } else {
            Cartesian3.normalize(normal, normal);
          }
          if (defined(axisTransform)) {
            Matrix4.multiplyByPointAsVector(axisTransform, normal, normal);
          }
          globalNormals.push(normal.x);
          globalNormals.push(normal.y);
          globalNormals.push(normal.z);
        } else if ((result = uvPattern.exec(line)) !== null) {
          globalUvs.push(parseFloat(result[1]));
          globalUvs.push(1 - parseFloat(result[2]));
        } else {
          if (line.slice(-1) === "\\") {
            lineBuffer += line.substring(0, line.length - 1);
            return;
          }
          lineBuffer += line;
          if (lineBuffer.substring(0, 2) === "f ") {
            while ((result = facePattern.exec(lineBuffer)) !== null) {
              faceVertices.push(result[0]);
              facePositions.push(result[1]);
              faceUvs.push(result[2]);
              faceNormals.push(result[3]);
            }
            if (faceVertices.length > 2) {
              addFace(
                faceVertices,
                facePositions,
                faceUvs,
                faceNormals,
                options.triangleWindingOrderSanitization
              );
            }
            faceVertices.length = 0;
            facePositions.length = 0;
            faceNormals.length = 0;
            faceUvs.length = 0;
          }
          lineBuffer = "";
        }
      }
      addNode();
      return readLines(objPath, parseLine).then(function() {
        globalPositions = void 0;
        globalNormals = void 0;
        globalUvs = void 0;
        return finishLoading(
          nodes,
          mtlPaths,
          objPath,
          defined(activeMaterial),
          options
        );
      });
    }
    function getMtlPaths(mtllibLine) {
      const mtlPaths = [];
      const splits = mtllibLine.split(" ");
      const length = splits.length;
      let startIndex = 0;
      for (let i = 0; i < length; ++i) {
        if (path.extname(splits[i]) !== ".mtl") {
          continue;
        }
        const mtlPath = splits.slice(startIndex, i + 1).join(" ");
        mtlPaths.push(mtlPath);
        startIndex = i + 1;
      }
      return mtlPaths;
    }
    function finishLoading(nodes, mtlPaths, objPath, usesMaterials, options) {
      nodes = cleanNodes(nodes);
      if (nodes.length === 0) {
        throw new RuntimeError(`${objPath} does not have any geometry data`);
      }
      const name = path.basename(objPath, path.extname(objPath));
      return loadMtls(mtlPaths, objPath, options).then(function(materials) {
        if (materials.length > 0 && !usesMaterials) {
          assignDefaultMaterial(nodes, materials, usesMaterials);
        }
        assignUnnamedMaterial(nodes, materials);
        return {
          nodes,
          materials,
          name
        };
      });
    }
    function normalizeMtlPath(mtlPath, objDirectory) {
      mtlPath = mtlPath.replace(/\\/g, "/");
      return path.normalize(path.resolve(objDirectory, mtlPath));
    }
    function loadMtls(mtlPaths, objPath, options) {
      const objDirectory = path.dirname(objPath);
      let materials = [];
      mtlPaths = mtlPaths.filter(function(value, index, self) {
        return self.indexOf(value) === index;
      });
      return Promise2.map(
        mtlPaths,
        function(mtlPath) {
          mtlPath = normalizeMtlPath(mtlPath, objDirectory);
          const shallowPath = path.join(objDirectory, path.basename(mtlPath));
          if (options.secure && outsideDirectory(mtlPath, objDirectory)) {
            options.logger(
              "The material file is outside of the obj directory and the secure flag is true. Attempting to read the material file from within the obj directory instead."
            );
            return loadMtl(shallowPath, options).then(function(materialsInMtl) {
              materials = materials.concat(materialsInMtl);
            }).catch(function(error) {
              options.logger(error.message);
              options.logger(
                `Could not read material file at ${shallowPath}. Using default material instead.`
              );
            });
          }
          return loadMtl(mtlPath, options).catch(function(error) {
            options.logger(error.message);
            options.logger(
              `Could not read material file at ${mtlPath}. Attempting to read the material file from within the obj directory instead.`
            );
            return loadMtl(shallowPath, options);
          }).then(function(materialsInMtl) {
            materials = materials.concat(materialsInMtl);
          }).catch(function(error) {
            options.logger(error.message);
            options.logger(
              `Could not read material file at ${shallowPath}. Using default material instead.`
            );
          });
        },
        { concurrency: 10 }
      ).then(function() {
        return materials;
      });
    }
    function assignDefaultMaterial(nodes, materials) {
      const defaultMaterial = materials[0].name;
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const meshes = nodes[i].meshes;
        const meshesLength = meshes.length;
        for (let j = 0; j < meshesLength; ++j) {
          const primitives = meshes[j].primitives;
          const primitivesLength = primitives.length;
          for (let k = 0; k < primitivesLength; ++k) {
            const primitive = primitives[k];
            primitive.material = defaultValue(primitive.material, defaultMaterial);
          }
        }
      }
    }
    function assignUnnamedMaterial(nodes, materials) {
      const unnamedMaterial = materials.find(function(material) {
        return material.name.length === 0;
      });
      if (!defined(unnamedMaterial)) {
        return;
      }
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const meshes = nodes[i].meshes;
        const meshesLength = meshes.length;
        for (let j = 0; j < meshesLength; ++j) {
          const primitives = meshes[j].primitives;
          const primitivesLength = primitives.length;
          for (let k = 0; k < primitivesLength; ++k) {
            const primitive = primitives[k];
            if (!defined(primitive.material)) {
              primitive.material = unnamedMaterial.name;
            }
          }
        }
      }
    }
    function removeEmptyMeshes(meshes) {
      return meshes.filter(function(mesh) {
        mesh.primitives = mesh.primitives.filter(function(primitive) {
          return primitive.indices.length > 0 && primitive.positions.length > 0;
        });
        return mesh.primitives.length > 0;
      });
    }
    function meshesHaveNames(meshes) {
      const meshesLength = meshes.length;
      for (let i = 0; i < meshesLength; ++i) {
        if (defined(meshes[i].name)) {
          return true;
        }
      }
      return false;
    }
    function removeEmptyNodes(nodes) {
      const final = [];
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const node = nodes[i];
        const meshes = removeEmptyMeshes(node.meshes);
        if (meshes.length === 0) {
          continue;
        }
        node.meshes = meshes;
        if (!defined(node.name) && meshesHaveNames(meshes)) {
          const meshesLength = meshes.length;
          for (let j = 0; j < meshesLength; ++j) {
            const mesh = meshes[j];
            const convertedNode = new Node();
            convertedNode.name = mesh.name;
            convertedNode.meshes = [mesh];
            final.push(convertedNode);
          }
        } else {
          final.push(node);
        }
      }
      return final;
    }
    function setDefaultNames(items, defaultName, usedNames) {
      const itemsLength = items.length;
      for (let i = 0; i < itemsLength; ++i) {
        const item = items[i];
        let name = defaultValue(item.name, defaultName);
        const occurrences = usedNames[name];
        if (defined(occurrences)) {
          usedNames[name]++;
          name = `${name}_${occurrences}`;
        } else {
          usedNames[name] = 1;
        }
        item.name = name;
      }
    }
    function setDefaults(nodes) {
      const usedNames = {};
      setDefaultNames(nodes, "Node", usedNames);
      const nodesLength = nodes.length;
      for (let i = 0; i < nodesLength; ++i) {
        const node = nodes[i];
        setDefaultNames(node.meshes, `${node.name}-Mesh`, usedNames);
      }
    }
    function cleanNodes(nodes) {
      nodes = removeEmptyNodes(nodes);
      setDefaults(nodes);
      return nodes;
    }
    function getAxisTransform(inputUpAxis, outputUpAxis) {
      if (inputUpAxis === "X" && outputUpAxis === "Y") {
        return Axis.X_UP_TO_Y_UP;
      } else if (inputUpAxis === "X" && outputUpAxis === "Z") {
        return Axis.X_UP_TO_Z_UP;
      } else if (inputUpAxis === "Y" && outputUpAxis === "X") {
        return Axis.Y_UP_TO_X_UP;
      } else if (inputUpAxis === "Y" && outputUpAxis === "Z") {
        return Axis.Y_UP_TO_Z_UP;
      } else if (inputUpAxis === "Z" && outputUpAxis === "X") {
        return Axis.Z_UP_TO_X_UP;
      } else if (inputUpAxis === "Z" && outputUpAxis === "Y") {
        return Axis.Z_UP_TO_Y_UP;
      }
    }
  }
});

// node_modules/obj2gltf/lib/getJsonBufferPadded.js
var require_getJsonBufferPadded = __commonJS({
  "node_modules/obj2gltf/lib/getJsonBufferPadded.js"(exports, module) {
    "use strict";
    module.exports = getJsonBufferPadded;
    function getJsonBufferPadded(json) {
      let string = JSON.stringify(json);
      const boundary = 4;
      const byteLength = Buffer.byteLength(string);
      const remainder = byteLength % boundary;
      const padding = remainder === 0 ? 0 : boundary - remainder;
      let whitespace = "";
      for (let i = 0; i < padding; ++i) {
        whitespace += " ";
      }
      string += whitespace;
      return Buffer.from(string);
    }
  }
});

// node_modules/obj2gltf/lib/gltfToGlb.js
var require_gltfToGlb = __commonJS({
  "node_modules/obj2gltf/lib/gltfToGlb.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var getJsonBufferPadded = require_getJsonBufferPadded();
    var defined = Cesium.defined;
    module.exports = gltfToGlb;
    function gltfToGlb(gltf, binaryBuffer) {
      const buffer = gltf.buffers[0];
      if (defined(buffer.uri)) {
        binaryBuffer = Buffer.alloc(0);
      }
      const jsonBuffer = getJsonBufferPadded(gltf);
      const glbLength = 12 + 8 + jsonBuffer.length + 8 + binaryBuffer.length;
      const glb = Buffer.alloc(glbLength);
      let byteOffset = 0;
      glb.writeUInt32LE(1179937895, byteOffset);
      byteOffset += 4;
      glb.writeUInt32LE(2, byteOffset);
      byteOffset += 4;
      glb.writeUInt32LE(glbLength, byteOffset);
      byteOffset += 4;
      glb.writeUInt32LE(jsonBuffer.length, byteOffset);
      byteOffset += 4;
      glb.writeUInt32LE(1313821514, byteOffset);
      byteOffset += 4;
      jsonBuffer.copy(glb, byteOffset);
      byteOffset += jsonBuffer.length;
      glb.writeUInt32LE(binaryBuffer.length, byteOffset);
      byteOffset += 4;
      glb.writeUInt32LE(5130562, byteOffset);
      byteOffset += 4;
      binaryBuffer.copy(glb, byteOffset);
      return glb;
    }
  }
});

// node_modules/obj2gltf/lib/writeGltf.js
var require_writeGltf = __commonJS({
  "node_modules/obj2gltf/lib/writeGltf.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var mime = require_mime();
    var PNG = require_png().PNG;
    var Promise2 = require_bluebird();
    var getBufferPadded = require_getBufferPadded();
    var gltfToGlb = require_gltfToGlb();
    var defined = Cesium.defined;
    var RuntimeError = Cesium.RuntimeError;
    module.exports = writeGltf;
    function writeGltf(gltf, options) {
      return encodeTextures(gltf).then(function() {
        const binary = options.binary;
        const separate = options.separate;
        const separateTextures = options.separateTextures;
        const promises = [];
        if (separateTextures) {
          promises.push(writeSeparateTextures(gltf, options));
        } else {
          writeEmbeddedTextures(gltf);
        }
        if (separate) {
          promises.push(writeSeparateBuffers(gltf, options));
        } else if (!binary) {
          writeEmbeddedBuffer(gltf);
        }
        const binaryBuffer = gltf.buffers[0].extras._obj2gltf.source;
        return Promise2.all(promises).then(function() {
          deleteExtras(gltf);
          removeEmpty(gltf);
          if (binary) {
            return gltfToGlb(gltf, binaryBuffer);
          }
          return gltf;
        });
      });
    }
    function encodePng(texture) {
      const rgbColorType = 2;
      const rgbaColorType = 6;
      const png = new PNG({
        width: texture.width,
        height: texture.height,
        colorType: texture.transparent ? rgbaColorType : rgbColorType,
        inputColorType: rgbaColorType,
        inputHasAlpha: true
      });
      png.data = texture.pixels;
      return new Promise2(function(resolve, reject) {
        const chunks = [];
        const stream = png.pack();
        stream.on("data", function(chunk) {
          chunks.push(chunk);
        });
        stream.on("end", function() {
          resolve(Buffer.concat(chunks));
        });
        stream.on("error", reject);
      });
    }
    function encodeTexture(texture) {
      if (!defined(texture.source) && defined(texture.pixels) && texture.extension === ".png") {
        return encodePng(texture).then(function(encoded) {
          texture.source = encoded;
        });
      }
    }
    function encodeTextures(gltf) {
      const encodePromises = [];
      const images = gltf.images;
      const length = images.length;
      for (let i = 0; i < length; ++i) {
        encodePromises.push(encodeTexture(images[i].extras._obj2gltf));
      }
      return Promise2.all(encodePromises);
    }
    function deleteExtras(gltf) {
      const buffers = gltf.buffers;
      const buffersLength = buffers.length;
      for (let i = 0; i < buffersLength; ++i) {
        delete buffers[i].extras;
      }
      const images = gltf.images;
      const imagesLength = images.length;
      for (let i = 0; i < imagesLength; ++i) {
        delete images[i].extras;
      }
    }
    function removeEmpty(json) {
      Object.keys(json).forEach(function(key) {
        if (!defined(json[key]) || Array.isArray(json[key]) && json[key].length === 0) {
          delete json[key];
        } else if (typeof json[key] === "object") {
          removeEmpty(json[key]);
        }
      });
    }
    function writeSeparateBuffers(gltf, options) {
      const buffers = gltf.buffers;
      return Promise2.map(
        buffers,
        function(buffer) {
          const source = buffer.extras._obj2gltf.source;
          const bufferUri = `${buffer.name}.bin`;
          buffer.uri = bufferUri;
          return options.writer(bufferUri, source);
        },
        { concurrency: 10 }
      );
    }
    function writeSeparateTextures(gltf, options) {
      const images = gltf.images;
      return Promise2.map(
        images,
        function(image) {
          const texture = image.extras._obj2gltf;
          const imageUri = image.name + texture.extension;
          image.uri = imageUri;
          return options.writer(imageUri, texture.source);
        },
        { concurrency: 10 }
      );
    }
    function writeEmbeddedBuffer(gltf) {
      const buffer = gltf.buffers[0];
      const source = buffer.extras._obj2gltf.source;
      if (source.length > 201326580) {
        throw new RuntimeError(
          "Buffer is too large to embed in the glTF. Use the --separate flag instead."
        );
      }
      buffer.uri = `data:application/octet-stream;base64,${source.toString(
        "base64"
      )}`;
    }
    function writeEmbeddedTextures(gltf) {
      const buffer = gltf.buffers[0];
      const bufferExtras = buffer.extras._obj2gltf;
      const bufferSource = bufferExtras.source;
      const images = gltf.images;
      const imagesLength = images.length;
      const sources = [bufferSource];
      let byteOffset = bufferSource.length;
      for (let i = 0; i < imagesLength; ++i) {
        const image = images[i];
        const texture = image.extras._obj2gltf;
        const textureSource = texture.source;
        const textureByteLength = textureSource.length;
        image.mimeType = mime.getType(texture.extension);
        image.bufferView = gltf.bufferViews.length;
        gltf.bufferViews.push({
          buffer: 0,
          byteOffset,
          byteLength: textureByteLength
        });
        byteOffset += textureByteLength;
        sources.push(textureSource);
      }
      const source = getBufferPadded(Buffer.concat(sources));
      bufferExtras.source = source;
      buffer.byteLength = source.length;
    }
  }
});

// node_modules/obj2gltf/lib/obj2gltf.js
var require_obj2gltf = __commonJS({
  "node_modules/obj2gltf/lib/obj2gltf.js"(exports, module) {
    "use strict";
    var Cesium = require_cesium();
    var fsExtra = require_lib();
    var path = require_path();
    var createGltf = require_createGltf();
    var loadObj = require_loadObj();
    var writeGltf = require_writeGltf();
    var defaultValue = Cesium.defaultValue;
    var defined = Cesium.defined;
    var DeveloperError = Cesium.DeveloperError;
    module.exports = obj2gltf;
    function obj2gltf(objPath, options) {
      const defaults = obj2gltf.defaults;
      options = defaultValue(options, {});
      options.binary = defaultValue(options.binary, defaults.binary);
      options.separate = defaultValue(options.separate, defaults.separate);
      options.separateTextures = defaultValue(options.separateTextures, defaults.separateTextures) || options.separate;
      options.checkTransparency = defaultValue(
        options.checkTransparency,
        defaults.checkTransparency
      );
      options.secure = defaultValue(options.secure, defaults.secure);
      options.packOcclusion = defaultValue(
        options.packOcclusion,
        defaults.packOcclusion
      );
      options.metallicRoughness = defaultValue(
        options.metallicRoughness,
        defaults.metallicRoughness
      );
      options.specularGlossiness = defaultValue(
        options.specularGlossiness,
        defaults.specularGlossiness
      );
      options.unlit = defaultValue(options.unlit, defaults.unlit);
      options.overridingTextures = defaultValue(
        options.overridingTextures,
        defaultValue.EMPTY_OBJECT
      );
      options.logger = defaultValue(options.logger, getDefaultLogger());
      options.writer = defaultValue(
        options.writer,
        getDefaultWriter(options.outputDirectory)
      );
      options.inputUpAxis = defaultValue(options.inputUpAxis, defaults.inputUpAxis);
      options.outputUpAxis = defaultValue(
        options.outputUpAxis,
        defaults.outputUpAxis
      );
      options.triangleWindingOrderSanitization = defaultValue(
        options.triangleWindingOrderSanitization,
        defaults.triangleWindingOrderSanitization
      );
      if (!defined(objPath)) {
        throw new DeveloperError("objPath is required");
      }
      if (options.separateTextures && !defined(options.writer)) {
        throw new DeveloperError(
          "Either options.writer or options.outputDirectory must be defined when writing separate resources."
        );
      }
      if (options.metallicRoughness + options.specularGlossiness + options.unlit > 1) {
        throw new DeveloperError(
          "Only one material type may be set from [metallicRoughness, specularGlossiness, unlit]."
        );
      }
      if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture) && defined(options.overridingTextures.specularGlossinessTexture)) {
        throw new DeveloperError(
          "metallicRoughnessOcclusionTexture and specularGlossinessTexture cannot both be defined."
        );
      }
      if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {
        options.metallicRoughness = true;
        options.specularGlossiness = false;
        options.packOcclusion = true;
      }
      if (defined(options.overridingTextures.specularGlossinessTexture)) {
        options.metallicRoughness = false;
        options.specularGlossiness = true;
      }
      return loadObj(objPath, options).then(function(objData) {
        return createGltf(objData, options);
      }).then(function(gltf) {
        return writeGltf(gltf, options);
      });
    }
    function getDefaultLogger() {
      return function(message) {
        console.log(message);
      };
    }
    function getDefaultWriter(outputDirectory) {
      if (defined(outputDirectory)) {
        return function(file, data) {
          const outputFile = path.join(outputDirectory, file);
          return fsExtra.outputFile(outputFile, data);
        };
      }
    }
    obj2gltf.defaults = {
      /**
       * Gets or sets whether the converter will return a glb.
       * @type Boolean
       * @default false
       */
      binary: false,
      /**
       * Gets or sets whether to write out separate buffer and texture,
       * shader files, and textures instead of embedding them in the glTF.
       * @type Boolean
       * @default false
       */
      separate: false,
      /**
       * Gets or sets whether to write out separate textures only.
       * @type Boolean
       * @default false
       */
      separateTextures: false,
      /**
       * Gets or sets whether the converter will do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.
       * @type Boolean
       * @default false
       */
      checkTransparency: false,
      /**
       * Gets or sets whether the source model can reference paths outside of its directory.
       * @type Boolean
       * @default false
       */
      secure: false,
      /**
       * Gets or sets whether to pack the occlusion texture in the red channel of the metallic-roughness texture.
       * @type Boolean
       * @default false
       */
      packOcclusion: false,
      /**
       * Gets or sets whether rhe values in the .mtl file are already metallic-roughness PBR values and no conversion step should be applied. Metallic is stored in the Ks and map_Ks slots and roughness is stored in the Ns and map_Ns slots.
       * @type Boolean
       * @default false
       */
      metallicRoughness: false,
      /**
       * Gets or sets whether the values in the .mtl file are already specular-glossiness PBR values and no conversion step should be applied. Specular is stored in the Ks and map_Ks slots and glossiness is stored in the Ns and map_Ns slots. The glTF will be saved with the KHR_materials_pbrSpecularGlossiness extension.
       * @type Boolean
       * @default false
       */
      specularGlossiness: false,
      /**
       * Gets or sets whether the glTF will be saved with the KHR_materials_unlit extension.
       * @type Boolean
       * @default false
       */
      unlit: false,
      /**
       * Gets or sets the up axis of the obj.
       * @type String
       * @default 'Y'
       */
      inputUpAxis: "Y",
      /**
       * Gets or sets the up axis of the converted glTF.
       * @type String
       * @default 'Y'
       */
      outputUpAxis: "Y",
      /**
       * Gets or sets whether triangle winding order sanitization will be applied.
       * @type Boolean
       * @default false
       */
      windingOrderSanitization: false
    };
  }
});

// node_modules/obj2gltf/index.js
var require_obj2gltf2 = __commonJS({
  "node_modules/obj2gltf/index.js"(exports, module) {
    module.exports = require_obj2gltf();
  }
});
export default require_obj2gltf2();
//# sourceMappingURL=obj2gltf.js.map
