{
  "version": 3,
  "sources": ["../../cesium/index.cjs", "../../obj2gltf/lib/getBufferPadded.js", "../../obj2gltf/lib/Texture.js", "../../obj2gltf/lib/loadTexture.js", "../../obj2gltf/lib/outsideDirectory.js", "browser-external:readline", "browser-external:events", "../../obj2gltf/lib/readLines.js", "../../obj2gltf/lib/loadMtl.js", "../../obj2gltf/lib/createGltf.js", "../../obj2gltf/lib/ArrayStorage.js", "../../obj2gltf/lib/loadObj.js", "../../obj2gltf/lib/getJsonBufferPadded.js", "../../obj2gltf/lib/gltfToGlb.js", "../../obj2gltf/lib/writeGltf.js", "../../obj2gltf/lib/obj2gltf.js", "../../obj2gltf/index.js"],
  "sourcesContent": ["/*eslint-env node*/\n\"use strict\";\n\nconst path = require(\"path\");\n\n// If in 'production' mode, use the combined/minified/optimized version of Cesium\nif (process.env.NODE_ENV === \"production\") {\n  // eslint-disable-next-line global-require\n  module.exports = require(path.join(__dirname, \"Build/Cesium/index.cjs\"));\n  return;\n}\n\nmodule.exports = require(path.join(\n  __dirname,\n  \"Build/CesiumUnminified/index.cjs\"\n));\n", "\"use strict\";\nmodule.exports = getBufferPadded;\n\n/**\n * Pad the buffer to the next 4-byte boundary to ensure proper alignment for the section that follows.\n *\n * @param {Buffer} buffer The buffer.\n * @returns {Buffer} The padded buffer.\n *\n * @private\n */\nfunction getBufferPadded(buffer) {\n  const boundary = 4;\n  const byteLength = buffer.length;\n  const remainder = byteLength % boundary;\n  if (remainder === 0) {\n    return buffer;\n  }\n  const padding = remainder === 0 ? 0 : boundary - remainder;\n  const emptyBuffer = Buffer.alloc(padding);\n  return Buffer.concat([buffer, emptyBuffer]);\n}\n", "\"use strict\";\n\nmodule.exports = Texture;\n\n/**\n * An object containing information about a texture.\n *\n * @private\n */\nfunction Texture() {\n  this.transparent = false;\n  this.source = undefined;\n  this.name = undefined;\n  this.extension = undefined;\n  this.path = undefined;\n  this.pixels = undefined;\n  this.width = undefined;\n  this.height = undefined;\n}\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst fsExtra = require(\"fs-extra\");\nconst jpeg = require(\"jpeg-js\");\nconst path = require(\"path\");\nconst PNG = require(\"pngjs\").PNG;\nconst Promise = require(\"bluebird\");\nconst Texture = require(\"./Texture\");\n\nconst defaultValue = Cesium.defaultValue;\nconst defined = Cesium.defined;\n\nmodule.exports = loadTexture;\n\n/**\n * Load a texture file.\n *\n * @param {String} texturePath Path to the texture file.\n * @param {Object} [options] An object with the following properties:\n * @param {Boolean} [options.checkTransparency=false] Do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.\n * @param {Boolean} [options.decode=false] Whether to decode the texture.\n * @param {Boolean} [options.keepSource=false] Whether to keep the source image contents in memory.\n * @returns {Promise} A promise resolving to a Texture object.\n *\n * @private\n */\nfunction loadTexture(texturePath, options) {\n  options = defaultValue(options, {});\n  options.checkTransparency = defaultValue(options.checkTransparency, false);\n  options.decode = defaultValue(options.decode, false);\n  options.keepSource = defaultValue(options.keepSource, false);\n\n  return fsExtra.readFile(texturePath).then(function (source) {\n    const name = path.basename(texturePath, path.extname(texturePath));\n    const extension = path.extname(texturePath).toLowerCase();\n    const texture = new Texture();\n    texture.source = source;\n    texture.name = name;\n    texture.extension = extension;\n    texture.path = texturePath;\n\n    let decodePromise;\n    if (extension === \".png\") {\n      decodePromise = decodePng(texture, options);\n    } else if (extension === \".jpg\" || extension === \".jpeg\") {\n      decodePromise = decodeJpeg(texture, options);\n    }\n\n    if (defined(decodePromise)) {\n      return decodePromise.then(function () {\n        return texture;\n      });\n    }\n\n    return texture;\n  });\n}\n\nfunction hasTransparency(pixels) {\n  const pixelsLength = pixels.length / 4;\n  for (let i = 0; i < pixelsLength; ++i) {\n    if (pixels[i * 4 + 3] < 255) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getChannels(colorType) {\n  switch (colorType) {\n    case 0: // greyscale\n      return 1;\n    case 2: // RGB\n      return 3;\n    case 4: // greyscale + alpha\n      return 2;\n    case 6: // RGB + alpha\n      return 4;\n    default:\n      return 3;\n  }\n}\n\nfunction parsePng(data) {\n  return new Promise(function (resolve, reject) {\n    new PNG().parse(data, function (error, decodedResults) {\n      if (defined(error)) {\n        reject(error);\n        return;\n      }\n      resolve(decodedResults);\n    });\n  });\n}\n\nfunction decodePng(texture, options) {\n  // Color type is encoded in the 25th bit of the png\n  const source = texture.source;\n  const colorType = source[25];\n  const channels = getChannels(colorType);\n\n  const checkTransparency = channels === 4 && options.checkTransparency;\n  const decode = options.decode || checkTransparency;\n\n  if (decode) {\n    return parsePng(source).then(function (decodedResults) {\n      if (options.checkTransparency) {\n        texture.transparent = hasTransparency(decodedResults.data);\n      }\n      if (options.decode) {\n        texture.pixels = decodedResults.data;\n        texture.width = decodedResults.width;\n        texture.height = decodedResults.height;\n        if (!options.keepSource) {\n          texture.source = undefined; // Unload resources\n        }\n      }\n    });\n  }\n}\n\nfunction decodeJpeg(texture, options) {\n  if (options.decode) {\n    const source = texture.source;\n    const decodedResults = jpeg.decode(source);\n    texture.pixels = decodedResults.data;\n    texture.width = decodedResults.width;\n    texture.height = decodedResults.height;\n    if (!options.keepSource) {\n      texture.source = undefined; // Unload resources\n    }\n  }\n}\n", "\"use strict\";\nconst path = require(\"path\");\n\nmodule.exports = outsideDirectory;\n\n/**\n * Checks if a file is outside of a directory.\n *\n * @param {String} file Path to the file.\n * @param {String} directory Path to the directory.\n * @returns {Boolean} Whether the file is outside of the directory.\n *\n * @private\n */\nfunction outsideDirectory(file, directory) {\n  return path.relative(directory, file).indexOf(\"..\") === 0;\n}\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"readline\" has been externalized for browser compatibility. Cannot access \"readline.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"events\" has been externalized for browser compatibility. Cannot access \"events.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "\"use strict\";\nconst fsExtra = require(\"fs-extra\");\nconst Promise = require(\"bluebird\");\nconst readline = require(\"readline\");\nconst events = require(\"events\");\n\nmodule.exports = readLines;\n\n/**\n * Read a file line-by-line.\n *\n * @param {String} path Path to the file.\n * @param {Function} callback Function to call when reading each line.\n * @returns {Promise} A promise when the reader is finished.\n *\n * @private\n */\nfunction readLines(path, callback) {\n  const stream = fsExtra.createReadStream(path);\n  return events.once(stream, \"open\").then(function () {\n    return new Promise(function (resolve, reject) {\n      stream.on(\"error\", reject);\n      stream.on(\"end\", resolve);\n\n      const lineReader = readline.createInterface({\n        input: stream,\n      });\n\n      const callbackWrapper = function (line) {\n        try {\n          callback(line);\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      lineReader.on(\"line\", callbackWrapper);\n    });\n  });\n}\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst path = require(\"path\");\nconst Promise = require(\"bluebird\");\nconst loadTexture = require(\"./loadTexture\");\nconst outsideDirectory = require(\"./outsideDirectory\");\nconst readLines = require(\"./readLines\");\nconst Texture = require(\"./Texture\");\n\nconst CesiumMath = Cesium.Math;\nconst clone = Cesium.clone;\nconst combine = Cesium.combine;\nconst defaultValue = Cesium.defaultValue;\nconst defined = Cesium.defined;\n\nmodule.exports = loadMtl;\n\n/**\n * Parse a .mtl file and load textures referenced within. Returns an array of glTF materials with Texture\n * objects stored in the texture slots.\n * <p>\n * Packed PBR textures (like metallicRoughnessOcclusion and specularGlossiness) require all input textures to be decoded before hand.\n * If a texture is of an unsupported format like .gif or .tga it can't be packed and a metallicRoughness texture will not be created.\n * Similarly if a texture cannot be found it will be ignored and a default value will be used instead.\n * </p>\n *\n * @param {String} mtlPath Path to the .mtl file.\n * @param {Object} options The options object passed along from lib/obj2gltf.js\n * @returns {Promise} A promise resolving to an array of glTF materials with Texture objects stored in the texture slots.\n *\n * @private\n */\nfunction loadMtl(mtlPath, options) {\n  let material;\n  let values;\n  let value;\n\n  const mtlDirectory = path.dirname(mtlPath);\n  const materials = [];\n  const texturePromiseMap = {}; // Maps texture paths to load promises so that no texture is loaded twice\n  const texturePromises = [];\n\n  const overridingTextures = options.overridingTextures;\n  const overridingSpecularTexture = defaultValue(\n    overridingTextures.metallicRoughnessOcclusionTexture,\n    overridingTextures.specularGlossinessTexture\n  );\n  const overridingSpecularShininessTexture = defaultValue(\n    overridingTextures.metallicRoughnessOcclusionTexture,\n    overridingTextures.specularGlossinessTexture\n  );\n  const overridingAmbientTexture = defaultValue(\n    overridingTextures.metallicRoughnessOcclusionTexture,\n    overridingTextures.occlusionTexture\n  );\n  const overridingNormalTexture = overridingTextures.normalTexture;\n  const overridingDiffuseTexture = overridingTextures.baseColorTexture;\n  const overridingEmissiveTexture = overridingTextures.emissiveTexture;\n  const overridingAlphaTexture = overridingTextures.alphaTexture;\n\n  // Textures that are packed into PBR textures need to be decoded first\n  const decodeOptions = {\n    decode: true,\n  };\n\n  const diffuseTextureOptions = {\n    checkTransparency: options.checkTransparency,\n  };\n\n  const ambientTextureOptions = defined(overridingAmbientTexture)\n    ? undefined\n    : options.packOcclusion\n    ? decodeOptions\n    : undefined;\n  const specularTextureOptions = defined(overridingSpecularTexture)\n    ? undefined\n    : decodeOptions;\n  const specularShinessTextureOptions = defined(\n    overridingSpecularShininessTexture\n  )\n    ? undefined\n    : decodeOptions;\n  const emissiveTextureOptions = undefined;\n  const normalTextureOptions = undefined;\n  const alphaTextureOptions = {\n    decode: true,\n  };\n\n  function createMaterial(name) {\n    material = new Material();\n    material.name = name;\n    material.specularShininess = options.metallicRoughness ? 1.0 : 0.0;\n    material.specularTexture = overridingSpecularTexture;\n    material.specularShininessTexture = overridingSpecularShininessTexture;\n    material.diffuseTexture = overridingDiffuseTexture;\n    material.ambientTexture = overridingAmbientTexture;\n    material.normalTexture = overridingNormalTexture;\n    material.emissiveTexture = overridingEmissiveTexture;\n    material.alphaTexture = overridingAlphaTexture;\n    materials.push(material);\n  }\n\n  function normalizeTexturePath(texturePath, mtlDirectory) {\n    // Removes texture options from texture name\n    // Assumes no spaces in texture name\n    const re = /-(bm|t|s|o|blendu|blendv|boost|mm|texres|clamp|imfchan|type)/;\n    if (re.test(texturePath)) {\n      texturePath = texturePath.split(/\\s+/).pop();\n    }\n    texturePath = texturePath.replace(/\\\\/g, \"/\");\n    return path.normalize(path.resolve(mtlDirectory, texturePath));\n  }\n\n  function parseLine(line) {\n    line = line.trim();\n    if (/^newmtl/i.test(line)) {\n      const name = line.substring(7).trim();\n      createMaterial(name);\n    } else if (/^Ka /i.test(line)) {\n      values = line.substring(3).trim().split(\" \");\n      material.ambientColor = [\n        parseFloat(values[0]),\n        parseFloat(values[1]),\n        parseFloat(values[2]),\n        1.0,\n      ];\n    } else if (/^Ke /i.test(line)) {\n      values = line.substring(3).trim().split(\" \");\n      material.emissiveColor = [\n        parseFloat(values[0]),\n        parseFloat(values[1]),\n        parseFloat(values[2]),\n        1.0,\n      ];\n    } else if (/^Kd /i.test(line)) {\n      values = line.substring(3).trim().split(\" \");\n      material.diffuseColor = [\n        parseFloat(values[0]),\n        parseFloat(values[1]),\n        parseFloat(values[2]),\n        1.0,\n      ];\n    } else if (/^Ks /i.test(line)) {\n      values = line.substring(3).trim().split(\" \");\n      material.specularColor = [\n        parseFloat(values[0]),\n        parseFloat(values[1]),\n        parseFloat(values[2]),\n        1.0,\n      ];\n    } else if (/^Ns /i.test(line)) {\n      value = line.substring(3).trim();\n      material.specularShininess = parseFloat(value);\n    } else if (/^d /i.test(line)) {\n      value = line.substring(2).trim();\n      material.alpha = correctAlpha(parseFloat(value));\n    } else if (/^Tr /i.test(line)) {\n      value = line.substring(3).trim();\n      material.alpha = correctAlpha(1.0 - parseFloat(value));\n    } else if (/^map_Ka /i.test(line)) {\n      if (!defined(overridingAmbientTexture)) {\n        material.ambientTexture = normalizeTexturePath(\n          line.substring(7).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_Ke /i.test(line)) {\n      if (!defined(overridingEmissiveTexture)) {\n        material.emissiveTexture = normalizeTexturePath(\n          line.substring(7).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_Kd /i.test(line)) {\n      if (!defined(overridingDiffuseTexture)) {\n        material.diffuseTexture = normalizeTexturePath(\n          line.substring(7).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_Ks /i.test(line)) {\n      if (!defined(overridingSpecularTexture)) {\n        material.specularTexture = normalizeTexturePath(\n          line.substring(7).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_Ns /i.test(line)) {\n      if (!defined(overridingSpecularShininessTexture)) {\n        material.specularShininessTexture = normalizeTexturePath(\n          line.substring(7).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_Bump /i.test(line)) {\n      if (!defined(overridingNormalTexture)) {\n        material.normalTexture = normalizeTexturePath(\n          line.substring(9).trim(),\n          mtlDirectory\n        );\n      }\n    } else if (/^map_d /i.test(line)) {\n      if (!defined(overridingAlphaTexture)) {\n        material.alphaTexture = normalizeTexturePath(\n          line.substring(6).trim(),\n          mtlDirectory\n        );\n      }\n    }\n  }\n\n  function loadMaterialTextures(material) {\n    // If an alpha texture is present the diffuse texture needs to be decoded so they can be packed together\n    const diffuseAlphaTextureOptions = defined(material.alphaTexture)\n      ? alphaTextureOptions\n      : diffuseTextureOptions;\n\n    if (material.diffuseTexture === material.ambientTexture) {\n      // OBJ models are often exported with the same texture in the diffuse and ambient slots but this is typically not desirable, particularly\n      // when saving with PBR materials where the ambient texture is treated as the occlusion texture.\n      material.ambientTexture = undefined;\n    }\n\n    const textureNames = [\n      \"diffuseTexture\",\n      \"ambientTexture\",\n      \"emissiveTexture\",\n      \"specularTexture\",\n      \"specularShininessTexture\",\n      \"normalTexture\",\n      \"alphaTexture\",\n    ];\n    const textureOptions = [\n      diffuseAlphaTextureOptions,\n      ambientTextureOptions,\n      emissiveTextureOptions,\n      specularTextureOptions,\n      specularShinessTextureOptions,\n      normalTextureOptions,\n      alphaTextureOptions,\n    ];\n\n    const sharedOptions = {};\n    textureNames.forEach(function (name, index) {\n      const texturePath = material[name];\n      const originalOptions = textureOptions[index];\n      if (defined(texturePath) && defined(originalOptions)) {\n        if (!defined(sharedOptions[texturePath])) {\n          sharedOptions[texturePath] = clone(originalOptions);\n        }\n        const options = sharedOptions[texturePath];\n        options.checkTransparency =\n          options.checkTransparency || originalOptions.checkTransparency;\n        options.decode = options.decode || originalOptions.decode;\n        options.keepSource =\n          options.keepSource ||\n          !originalOptions.decode ||\n          !originalOptions.checkTransparency;\n      }\n    });\n\n    textureNames.forEach(function (name) {\n      const texturePath = material[name];\n      if (defined(texturePath)) {\n        loadMaterialTexture(\n          material,\n          name,\n          sharedOptions[texturePath],\n          mtlDirectory,\n          texturePromiseMap,\n          texturePromises,\n          options\n        );\n      }\n    });\n  }\n\n  return readLines(mtlPath, parseLine)\n    .then(function () {\n      const length = materials.length;\n      for (let i = 0; i < length; ++i) {\n        loadMaterialTextures(materials[i]);\n      }\n      return Promise.all(texturePromises);\n    })\n    .then(function () {\n      return convertMaterials(materials, options);\n    });\n}\n\nfunction correctAlpha(alpha) {\n  // An alpha of 0.0 usually implies a problem in the export, change to 1.0 instead\n  return alpha === 0.0 ? 1.0 : alpha;\n}\n\nfunction Material() {\n  this.name = undefined;\n  this.ambientColor = [0.0, 0.0, 0.0, 1.0]; // Ka\n  this.emissiveColor = [0.0, 0.0, 0.0, 1.0]; // Ke\n  this.diffuseColor = [0.5, 0.5, 0.5, 1.0]; // Kd\n  this.specularColor = [0.0, 0.0, 0.0, 1.0]; // Ks\n  this.specularShininess = 0.0; // Ns\n  this.alpha = 1.0; // d / Tr\n  this.ambientTexture = undefined; // map_Ka\n  this.emissiveTexture = undefined; // map_Ke\n  this.diffuseTexture = undefined; // map_Kd\n  this.specularTexture = undefined; // map_Ks\n  this.specularShininessTexture = undefined; // map_Ns\n  this.normalTexture = undefined; // map_Bump\n  this.alphaTexture = undefined; // map_d\n}\n\nloadMtl.getDefaultMaterial = function (options) {\n  return convertMaterial(new Material(), options);\n};\n\n// Exposed for testing\nloadMtl._createMaterial = function (materialOptions, options) {\n  return convertMaterial(combine(materialOptions, new Material()), options);\n};\n\nfunction loadMaterialTexture(\n  material,\n  name,\n  textureOptions,\n  mtlDirectory,\n  texturePromiseMap,\n  texturePromises,\n  options\n) {\n  const texturePath = material[name];\n  if (!defined(texturePath)) {\n    return;\n  }\n\n  let texturePromise = texturePromiseMap[texturePath];\n  if (!defined(texturePromise)) {\n    const shallowPath = path.join(mtlDirectory, path.basename(texturePath));\n    if (options.secure && outsideDirectory(texturePath, mtlDirectory)) {\n      // Try looking for the texture in the same directory as the obj\n      options.logger(\n        \"Texture file is outside of the mtl directory and the secure flag is true. Attempting to read the texture file from within the obj directory instead.\"\n      );\n      texturePromise = loadTexture(shallowPath, textureOptions).catch(function (\n        error\n      ) {\n        options.logger(error.message);\n        options.logger(\n          `Could not read texture file at ${shallowPath}. This texture will be ignored`\n        );\n      });\n    } else {\n      texturePromise = loadTexture(texturePath, textureOptions)\n        .catch(function (error) {\n          // Try looking for the texture in the same directory as the obj\n          options.logger(error.message);\n          options.logger(\n            `Could not read texture file at ${texturePath}. Attempting to read the texture file from within the obj directory instead.`\n          );\n          return loadTexture(shallowPath, textureOptions);\n        })\n        .catch(function (error) {\n          options.logger(error.message);\n          options.logger(\n            `Could not read texture file at ${shallowPath}. This texture will be ignored.`\n          );\n        });\n    }\n    texturePromiseMap[texturePath] = texturePromise;\n  }\n\n  texturePromises.push(\n    texturePromise.then(function (texture) {\n      material[name] = texture;\n    })\n  );\n}\n\nfunction convertMaterial(material, options) {\n  if (options.specularGlossiness) {\n    return createSpecularGlossinessMaterial(material, options);\n  } else if (options.metallicRoughness) {\n    return createMetallicRoughnessMaterial(material, options);\n  }\n  // No material type specified, convert the material to metallic roughness\n  convertTraditionalToMetallicRoughness(material);\n  return createMetallicRoughnessMaterial(material, options);\n}\n\nfunction convertMaterials(materials, options) {\n  return materials.map(function (material) {\n    return convertMaterial(material, options);\n  });\n}\n\nfunction resizeChannel(\n  sourcePixels,\n  sourceWidth,\n  sourceHeight,\n  targetPixels,\n  targetWidth,\n  targetHeight\n) {\n  // Nearest neighbor sampling\n  const widthRatio = sourceWidth / targetWidth;\n  const heightRatio = sourceHeight / targetHeight;\n\n  for (let y = 0; y < targetHeight; ++y) {\n    for (let x = 0; x < targetWidth; ++x) {\n      const targetIndex = y * targetWidth + x;\n      const sourceY = Math.round(y * heightRatio);\n      const sourceX = Math.round(x * widthRatio);\n      const sourceIndex = sourceY * sourceWidth + sourceX;\n      const sourceValue = sourcePixels.readUInt8(sourceIndex);\n      targetPixels.writeUInt8(sourceValue, targetIndex);\n    }\n  }\n  return targetPixels;\n}\n\nlet scratchResizeChannel;\n\nfunction getTextureChannel(\n  texture,\n  index,\n  targetWidth,\n  targetHeight,\n  targetChannel\n) {\n  const pixels = texture.pixels; // RGBA\n  const sourceWidth = texture.width;\n  const sourceHeight = texture.height;\n  const sourcePixelsLength = sourceWidth * sourceHeight;\n  const targetPixelsLength = targetWidth * targetHeight;\n\n  // Allocate the scratchResizeChannel on demand if the texture needs to be resized\n  let sourceChannel = targetChannel;\n  if (sourcePixelsLength > targetPixelsLength) {\n    if (\n      !defined(scratchResizeChannel) ||\n      sourcePixelsLength > scratchResizeChannel.length\n    ) {\n      scratchResizeChannel = Buffer.alloc(sourcePixelsLength);\n    }\n    sourceChannel = scratchResizeChannel;\n  }\n\n  for (let i = 0; i < sourcePixelsLength; ++i) {\n    const value = pixels.readUInt8(i * 4 + index);\n    sourceChannel.writeUInt8(value, i);\n  }\n\n  if (sourcePixelsLength > targetPixelsLength) {\n    resizeChannel(\n      sourceChannel,\n      sourceWidth,\n      sourceHeight,\n      targetChannel,\n      targetWidth,\n      targetHeight\n    );\n  }\n\n  return targetChannel;\n}\n\nfunction writeChannel(pixels, channel, index) {\n  const pixelsLength = pixels.length / 4;\n  for (let i = 0; i < pixelsLength; ++i) {\n    const value = channel.readUInt8(i);\n    pixels.writeUInt8(value, i * 4 + index);\n  }\n}\n\nfunction getMinimumDimensions(textures, options) {\n  let width = Number.POSITIVE_INFINITY;\n  let height = Number.POSITIVE_INFINITY;\n\n  const length = textures.length;\n  for (let i = 0; i < length; ++i) {\n    const texture = textures[i];\n    width = Math.min(texture.width, width);\n    height = Math.min(texture.height, height);\n  }\n\n  for (let i = 0; i < length; ++i) {\n    const texture = textures[i];\n    if (texture.width !== width || texture.height !== height) {\n      options.logger(\n        `Texture ${texture.path} will be scaled from ${texture.width}x${texture.height} to ${width}x${height}.`\n      );\n    }\n  }\n\n  return [width, height];\n}\n\nfunction isChannelSingleColor(buffer) {\n  const first = buffer.readUInt8(0);\n  const length = buffer.length;\n  for (let i = 1; i < length; ++i) {\n    if (buffer[i] !== first) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createDiffuseAlphaTexture(diffuseTexture, alphaTexture, options) {\n  const packDiffuse = defined(diffuseTexture);\n  const packAlpha = defined(alphaTexture);\n\n  if (!packDiffuse) {\n    return undefined;\n  }\n\n  if (!packAlpha) {\n    return diffuseTexture;\n  }\n\n  if (diffuseTexture === alphaTexture) {\n    return diffuseTexture;\n  }\n\n  if (!defined(diffuseTexture.pixels) || !defined(alphaTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${diffuseTexture.path} or ${alphaTexture.path}. The material will be created without an alpha texture.`\n    );\n    return diffuseTexture;\n  }\n\n  const packedTextures = [diffuseTexture, alphaTexture];\n  const dimensions = getMinimumDimensions(packedTextures, options);\n  const width = dimensions[0];\n  const height = dimensions[1];\n  const pixelsLength = width * height;\n  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels\n  const scratchChannel = Buffer.alloc(pixelsLength);\n\n  // Write into the R, G, B channels\n  const redChannel = getTextureChannel(\n    diffuseTexture,\n    0,\n    width,\n    height,\n    scratchChannel\n  );\n  writeChannel(pixels, redChannel, 0);\n  const greenChannel = getTextureChannel(\n    diffuseTexture,\n    1,\n    width,\n    height,\n    scratchChannel\n  );\n  writeChannel(pixels, greenChannel, 1);\n  const blueChannel = getTextureChannel(\n    diffuseTexture,\n    2,\n    width,\n    height,\n    scratchChannel\n  );\n  writeChannel(pixels, blueChannel, 2);\n\n  // First try reading the alpha component from the alpha channel, but if it is a single color read from the red channel instead.\n  let alphaChannel = getTextureChannel(\n    alphaTexture,\n    3,\n    width,\n    height,\n    scratchChannel\n  );\n  if (isChannelSingleColor(alphaChannel)) {\n    alphaChannel = getTextureChannel(\n      alphaTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n  }\n  writeChannel(pixels, alphaChannel, 3);\n\n  const texture = new Texture();\n  texture.name = diffuseTexture.name;\n  texture.extension = \".png\";\n  texture.pixels = pixels;\n  texture.width = width;\n  texture.height = height;\n  texture.transparent = true;\n\n  return texture;\n}\n\nfunction createMetallicRoughnessTexture(\n  metallicTexture,\n  roughnessTexture,\n  occlusionTexture,\n  options\n) {\n  if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {\n    return metallicTexture;\n  }\n\n  const packMetallic = defined(metallicTexture);\n  const packRoughness = defined(roughnessTexture);\n  const packOcclusion = defined(occlusionTexture) && options.packOcclusion;\n\n  if (!packMetallic && !packRoughness) {\n    return undefined;\n  }\n\n  if (packMetallic && !defined(metallicTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${metallicTexture.path}. The material will be created without a metallicRoughness texture.`\n    );\n    return undefined;\n  }\n\n  if (packRoughness && !defined(roughnessTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${roughnessTexture.path}. The material will be created without a metallicRoughness texture.`\n    );\n    return undefined;\n  }\n\n  if (packOcclusion && !defined(occlusionTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${occlusionTexture.path}. The occlusion texture will not be packed in the metallicRoughness texture.`\n    );\n    return undefined;\n  }\n\n  const packedTextures = [\n    metallicTexture,\n    roughnessTexture,\n    occlusionTexture,\n  ].filter(function (texture) {\n    return defined(texture) && defined(texture.pixels);\n  });\n\n  const dimensions = getMinimumDimensions(packedTextures, options);\n  const width = dimensions[0];\n  const height = dimensions[1];\n  const pixelsLength = width * height;\n  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels, unused channels will be white\n  const scratchChannel = Buffer.alloc(pixelsLength);\n\n  if (packMetallic) {\n    // Write into the B channel\n    const metallicChannel = getTextureChannel(\n      metallicTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, metallicChannel, 2);\n  }\n\n  if (packRoughness) {\n    // Write into the G channel\n    const roughnessChannel = getTextureChannel(\n      roughnessTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, roughnessChannel, 1);\n  }\n\n  if (packOcclusion) {\n    // Write into the R channel\n    const occlusionChannel = getTextureChannel(\n      occlusionTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, occlusionChannel, 0);\n  }\n\n  const length = packedTextures.length;\n  const names = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    names[i] = packedTextures[i].name;\n  }\n  const name = names.join(\"_\");\n\n  const texture = new Texture();\n  texture.name = name;\n  texture.extension = \".png\";\n  texture.pixels = pixels;\n  texture.width = width;\n  texture.height = height;\n\n  return texture;\n}\n\nfunction createSpecularGlossinessTexture(\n  specularTexture,\n  glossinessTexture,\n  options\n) {\n  if (defined(options.overridingTextures.specularGlossinessTexture)) {\n    return specularTexture;\n  }\n\n  const packSpecular = defined(specularTexture);\n  const packGlossiness = defined(glossinessTexture);\n\n  if (!packSpecular && !packGlossiness) {\n    return undefined;\n  }\n\n  if (packSpecular && !defined(specularTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${specularTexture.path}. The material will be created without a specularGlossiness texture.`\n    );\n    return undefined;\n  }\n\n  if (packGlossiness && !defined(glossinessTexture.pixels)) {\n    options.logger(\n      `Could not get decoded texture data for ${glossinessTexture.path}. The material will be created without a specularGlossiness texture.`\n    );\n    return undefined;\n  }\n\n  const packedTextures = [specularTexture, glossinessTexture].filter(function (\n    texture\n  ) {\n    return defined(texture) && defined(texture.pixels);\n  });\n\n  const dimensions = getMinimumDimensions(packedTextures, options);\n  const width = dimensions[0];\n  const height = dimensions[1];\n  const pixelsLength = width * height;\n  const pixels = Buffer.alloc(pixelsLength * 4, 0xff); // Initialize with 4 channels, unused channels will be white\n  const scratchChannel = Buffer.alloc(pixelsLength);\n\n  if (packSpecular) {\n    // Write into the R, G, B channels\n    const redChannel = getTextureChannel(\n      specularTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, redChannel, 0);\n    const greenChannel = getTextureChannel(\n      specularTexture,\n      1,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, greenChannel, 1);\n    const blueChannel = getTextureChannel(\n      specularTexture,\n      2,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, blueChannel, 2);\n  }\n\n  if (packGlossiness) {\n    // Write into the A channel\n    const glossinessChannel = getTextureChannel(\n      glossinessTexture,\n      0,\n      width,\n      height,\n      scratchChannel\n    );\n    writeChannel(pixels, glossinessChannel, 3);\n  }\n\n  const length = packedTextures.length;\n  const names = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    names[i] = packedTextures[i].name;\n  }\n  const name = names.join(\"_\");\n\n  const texture = new Texture();\n  texture.name = name;\n  texture.extension = \".png\";\n  texture.pixels = pixels;\n  texture.width = width;\n  texture.height = height;\n\n  return texture;\n}\n\nfunction createSpecularGlossinessMaterial(material, options) {\n  const emissiveTexture = material.emissiveTexture;\n  const normalTexture = material.normalTexture;\n  const occlusionTexture = material.ambientTexture;\n  const diffuseTexture = material.diffuseTexture;\n  const alphaTexture = material.alphaTexture;\n  const specularTexture = material.specularTexture;\n  const glossinessTexture = material.specularShininessTexture;\n  const specularGlossinessTexture = createSpecularGlossinessTexture(\n    specularTexture,\n    glossinessTexture,\n    options\n  );\n  const diffuseAlphaTexture = createDiffuseAlphaTexture(\n    diffuseTexture,\n    alphaTexture,\n    options\n  );\n\n  let emissiveFactor = material.emissiveColor.slice(0, 3);\n  let diffuseFactor = material.diffuseColor;\n  let specularFactor = material.specularColor.slice(0, 3);\n  let glossinessFactor = material.specularShininess;\n\n  if (defined(emissiveTexture)) {\n    emissiveFactor = [1.0, 1.0, 1.0];\n  }\n\n  if (defined(diffuseTexture)) {\n    diffuseFactor = [1.0, 1.0, 1.0, 1.0];\n  }\n\n  if (defined(specularTexture)) {\n    specularFactor = [1.0, 1.0, 1.0];\n  }\n\n  if (defined(glossinessTexture)) {\n    glossinessFactor = 1.0;\n  }\n\n  let transparent = false;\n  if (defined(alphaTexture)) {\n    transparent = true;\n  } else {\n    const alpha = material.alpha;\n    diffuseFactor[3] = alpha;\n    transparent = alpha < 1.0;\n  }\n\n  if (defined(diffuseTexture)) {\n    transparent = transparent || diffuseTexture.transparent;\n  }\n\n  const doubleSided = transparent;\n  const alphaMode = transparent ? \"BLEND\" : \"OPAQUE\";\n\n  return {\n    name: material.name,\n    extensions: {\n      KHR_materials_pbrSpecularGlossiness: {\n        diffuseTexture: diffuseAlphaTexture,\n        specularGlossinessTexture: specularGlossinessTexture,\n        diffuseFactor: diffuseFactor,\n        specularFactor: specularFactor,\n        glossinessFactor: glossinessFactor,\n      },\n    },\n    emissiveTexture: emissiveTexture,\n    normalTexture: normalTexture,\n    occlusionTexture: occlusionTexture,\n    emissiveFactor: emissiveFactor,\n    alphaMode: alphaMode,\n    doubleSided: doubleSided,\n  };\n}\n\nfunction createMetallicRoughnessMaterial(material, options) {\n  const emissiveTexture = material.emissiveTexture;\n  const normalTexture = material.normalTexture;\n  let occlusionTexture = material.ambientTexture;\n  const baseColorTexture = material.diffuseTexture;\n  const alphaTexture = material.alphaTexture;\n  const metallicTexture = material.specularTexture;\n  const roughnessTexture = material.specularShininessTexture;\n  const metallicRoughnessTexture = createMetallicRoughnessTexture(\n    metallicTexture,\n    roughnessTexture,\n    occlusionTexture,\n    options\n  );\n  const diffuseAlphaTexture = createDiffuseAlphaTexture(\n    baseColorTexture,\n    alphaTexture,\n    options\n  );\n\n  if (options.packOcclusion) {\n    occlusionTexture = metallicRoughnessTexture;\n  }\n\n  let emissiveFactor = material.emissiveColor.slice(0, 3);\n  let baseColorFactor = material.diffuseColor;\n  let metallicFactor = material.specularColor[0];\n  let roughnessFactor = material.specularShininess;\n\n  if (defined(emissiveTexture)) {\n    emissiveFactor = [1.0, 1.0, 1.0];\n  }\n\n  if (defined(baseColorTexture)) {\n    baseColorFactor = [1.0, 1.0, 1.0, 1.0];\n  }\n\n  if (defined(metallicTexture)) {\n    metallicFactor = 1.0;\n  }\n\n  if (defined(roughnessTexture)) {\n    roughnessFactor = 1.0;\n  }\n\n  let transparent = false;\n  if (defined(alphaTexture)) {\n    transparent = true;\n  } else {\n    const alpha = material.alpha;\n    baseColorFactor[3] = alpha;\n    transparent = alpha < 1.0;\n  }\n\n  if (defined(baseColorTexture)) {\n    transparent = transparent || baseColorTexture.transparent;\n  }\n\n  const doubleSided = transparent;\n  const alphaMode = transparent ? \"BLEND\" : \"OPAQUE\";\n\n  return {\n    name: material.name,\n    pbrMetallicRoughness: {\n      baseColorTexture: diffuseAlphaTexture,\n      metallicRoughnessTexture: metallicRoughnessTexture,\n      baseColorFactor: baseColorFactor,\n      metallicFactor: metallicFactor,\n      roughnessFactor: roughnessFactor,\n    },\n    emissiveTexture: emissiveTexture,\n    normalTexture: normalTexture,\n    occlusionTexture: occlusionTexture,\n    emissiveFactor: emissiveFactor,\n    alphaMode: alphaMode,\n    doubleSided: doubleSided,\n  };\n}\n\nfunction luminance(color) {\n  return color[0] * 0.2125 + color[1] * 0.7154 + color[2] * 0.0721;\n}\n\nfunction convertTraditionalToMetallicRoughness(material) {\n  // Translate the blinn-phong model to the pbr metallic-roughness model\n  // Roughness factor is a combination of specular intensity and shininess\n  // Metallic factor is 0.0\n  // Textures are not converted for now\n  const specularIntensity = luminance(material.specularColor);\n\n  // Transform from 0-1000 range to 0-1 range. Then invert.\n  let roughnessFactor = material.specularShininess;\n  roughnessFactor = roughnessFactor / 1000.0;\n  roughnessFactor = 1.0 - roughnessFactor;\n  roughnessFactor = CesiumMath.clamp(roughnessFactor, 0.0, 1.0);\n\n  // Low specular intensity values should produce a rough material even if shininess is high.\n  if (specularIntensity < 0.1) {\n    roughnessFactor *= 1.0 - specularIntensity;\n  }\n\n  const metallicFactor = 0.0;\n\n  material.specularColor = [\n    metallicFactor,\n    metallicFactor,\n    metallicFactor,\n    1.0,\n  ];\n  material.specularShininess = roughnessFactor;\n}\n", "\"use strict\";\nconst FS_WRITE_MAX_LENGTH = 2147479552; // See https://github.com/nodejs/node/issues/35605\nconst BUFFER_MAX_LENGTH = require(\"buffer\").constants.MAX_LENGTH;\nconst BUFFER_MAX_BYTE_LENGTH = Math.min(FS_WRITE_MAX_LENGTH, BUFFER_MAX_LENGTH);\nconst Cesium = require(\"cesium\");\nconst getBufferPadded = require(\"./getBufferPadded\");\nconst getDefaultMaterial = require(\"./loadMtl\").getDefaultMaterial;\nconst Texture = require(\"./Texture\");\n\nconst defaultValue = Cesium.defaultValue;\nconst defined = Cesium.defined;\nconst WebGLConstants = Cesium.WebGLConstants;\n\nmodule.exports = createGltf;\n\n/**\n * Create a glTF from obj data.\n *\n * @param {Object} objData An object containing an array of nodes containing geometry information and an array of materials.\n * @param {Object} options The options object passed along from lib/obj2gltf.js\n * @returns {Object} A glTF asset.\n *\n * @private\n */\nfunction createGltf(objData, options) {\n  const nodes = objData.nodes;\n  let materials = objData.materials;\n  const name = objData.name;\n\n  // Split materials used by primitives with different types of attributes\n  materials = splitIncompatibleMaterials(nodes, materials, options);\n\n  const gltf = {\n    accessors: [],\n    asset: {},\n    buffers: [],\n    bufferViews: [],\n    extensionsUsed: [],\n    extensionsRequired: [],\n    images: [],\n    materials: [],\n    meshes: [],\n    nodes: [],\n    samplers: [],\n    scene: 0,\n    scenes: [],\n    textures: [],\n  };\n\n  gltf.asset = {\n    generator: \"obj2gltf\",\n    version: \"2.0\",\n  };\n\n  gltf.scenes.push({\n    nodes: [],\n  });\n\n  const bufferState = {\n    positionBuffers: [],\n    normalBuffers: [],\n    uvBuffers: [],\n    indexBuffers: [],\n    positionAccessors: [],\n    normalAccessors: [],\n    uvAccessors: [],\n    indexAccessors: [],\n  };\n\n  const uint32Indices = requiresUint32Indices(nodes);\n\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const node = nodes[i];\n    const meshes = node.meshes;\n    const meshesLength = meshes.length;\n\n    if (meshesLength === 1) {\n      const meshIndex = addMesh(\n        gltf,\n        materials,\n        bufferState,\n        uint32Indices,\n        meshes[0],\n        options\n      );\n      addNode(gltf, node.name, meshIndex, undefined);\n    } else {\n      // Add meshes as child nodes\n      const parentIndex = addNode(gltf, node.name);\n      for (let j = 0; j < meshesLength; ++j) {\n        const mesh = meshes[j];\n        const meshIndex = addMesh(\n          gltf,\n          materials,\n          bufferState,\n          uint32Indices,\n          mesh,\n          options\n        );\n        addNode(gltf, mesh.name, meshIndex, parentIndex);\n      }\n    }\n  }\n\n  if (gltf.images.length > 0) {\n    gltf.samplers.push({\n      wrapS: WebGLConstants.REPEAT,\n      wrapT: WebGLConstants.REPEAT,\n    });\n  }\n\n  addBuffers(gltf, bufferState, name, options.separate);\n\n  if (options.specularGlossiness) {\n    gltf.extensionsUsed.push(\"KHR_materials_pbrSpecularGlossiness\");\n    gltf.extensionsRequired.push(\"KHR_materials_pbrSpecularGlossiness\");\n  }\n\n  if (options.unlit) {\n    gltf.extensionsUsed.push(\"KHR_materials_unlit\");\n    gltf.extensionsRequired.push(\"KHR_materials_unlit\");\n  }\n\n  return gltf;\n}\n\nfunction addCombinedBufferView(gltf, buffers, accessors, byteStride, target) {\n  const length = buffers.length;\n  if (length === 0) {\n    return;\n  }\n  const bufferViewIndex = gltf.bufferViews.length;\n  const previousBufferView = gltf.bufferViews[bufferViewIndex - 1];\n  const byteOffset = defined(previousBufferView)\n    ? previousBufferView.byteOffset + previousBufferView.byteLength\n    : 0;\n  let byteLength = 0;\n  for (let i = 0; i < length; ++i) {\n    const accessor = gltf.accessors[accessors[i]];\n    accessor.bufferView = bufferViewIndex;\n    accessor.byteOffset = byteLength;\n    byteLength += buffers[i].length;\n  }\n  gltf.bufferViews.push({\n    name: `bufferView_${bufferViewIndex}`,\n    buffer: 0,\n    byteLength: byteLength,\n    byteOffset: byteOffset,\n    byteStride: byteStride,\n    target: target,\n  });\n}\n\nfunction addCombinedBuffers(gltf, bufferState, name) {\n  addCombinedBufferView(\n    gltf,\n    bufferState.positionBuffers,\n    bufferState.positionAccessors,\n    12,\n    WebGLConstants.ARRAY_BUFFER\n  );\n  addCombinedBufferView(\n    gltf,\n    bufferState.normalBuffers,\n    bufferState.normalAccessors,\n    12,\n    WebGLConstants.ARRAY_BUFFER\n  );\n  addCombinedBufferView(\n    gltf,\n    bufferState.uvBuffers,\n    bufferState.uvAccessors,\n    8,\n    WebGLConstants.ARRAY_BUFFER\n  );\n  addCombinedBufferView(\n    gltf,\n    bufferState.indexBuffers,\n    bufferState.indexAccessors,\n    undefined,\n    WebGLConstants.ELEMENT_ARRAY_BUFFER\n  );\n\n  let buffers = [];\n  buffers = buffers.concat(\n    bufferState.positionBuffers,\n    bufferState.normalBuffers,\n    bufferState.uvBuffers,\n    bufferState.indexBuffers\n  );\n  const buffer = getBufferPadded(Buffer.concat(buffers));\n\n  gltf.buffers.push({\n    name: name,\n    byteLength: buffer.length,\n    extras: {\n      _obj2gltf: {\n        source: buffer,\n      },\n    },\n  });\n}\n\nfunction addSeparateBufferView(\n  gltf,\n  buffer,\n  accessor,\n  byteStride,\n  target,\n  name\n) {\n  const bufferIndex = gltf.buffers.length;\n  const bufferViewIndex = gltf.bufferViews.length;\n\n  gltf.buffers.push({\n    name: `${name}_${bufferIndex}`,\n    byteLength: buffer.length,\n    extras: {\n      _obj2gltf: {\n        source: buffer,\n      },\n    },\n  });\n\n  gltf.bufferViews.push({\n    buffer: bufferIndex,\n    byteLength: buffer.length,\n    byteOffset: 0,\n    byteStride: byteStride,\n    target: target,\n  });\n\n  gltf.accessors[accessor].bufferView = bufferViewIndex;\n  gltf.accessors[accessor].byteOffset = 0;\n}\n\nfunction addSeparateBufferViews(\n  gltf,\n  buffers,\n  accessors,\n  byteStride,\n  target,\n  name\n) {\n  const length = buffers.length;\n  for (let i = 0; i < length; ++i) {\n    addSeparateBufferView(\n      gltf,\n      buffers[i],\n      accessors[i],\n      byteStride,\n      target,\n      name\n    );\n  }\n}\n\nfunction addSeparateBuffers(gltf, bufferState, name) {\n  addSeparateBufferViews(\n    gltf,\n    bufferState.positionBuffers,\n    bufferState.positionAccessors,\n    12,\n    WebGLConstants.ARRAY_BUFFER,\n    name\n  );\n  addSeparateBufferViews(\n    gltf,\n    bufferState.normalBuffers,\n    bufferState.normalAccessors,\n    12,\n    WebGLConstants.ARRAY_BUFFER,\n    name\n  );\n  addSeparateBufferViews(\n    gltf,\n    bufferState.uvBuffers,\n    bufferState.uvAccessors,\n    8,\n    WebGLConstants.ARRAY_BUFFER,\n    name\n  );\n  addSeparateBufferViews(\n    gltf,\n    bufferState.indexBuffers,\n    bufferState.indexAccessors,\n    undefined,\n    WebGLConstants.ELEMENT_ARRAY_BUFFER,\n    name\n  );\n}\n\nfunction addBuffers(gltf, bufferState, name, separate) {\n  const buffers = bufferState.positionBuffers.concat(\n    bufferState.normalBuffers,\n    bufferState.uvBuffers,\n    bufferState.indexBuffers\n  );\n  const buffersLength = buffers.length;\n  let buffersByteLength = 0;\n  for (let i = 0; i < buffersLength; ++i) {\n    buffersByteLength += buffers[i].length;\n  }\n\n  if (separate && buffersByteLength > createGltf._getBufferMaxByteLength()) {\n    // Don't combine buffers if the combined buffer will exceed the Node limit.\n    addSeparateBuffers(gltf, bufferState, name);\n  } else {\n    addCombinedBuffers(gltf, bufferState, name);\n  }\n}\n\nfunction addTexture(gltf, texture) {\n  const imageName = texture.name;\n  const textureName = texture.name;\n  const imageIndex = gltf.images.length;\n  const textureIndex = gltf.textures.length;\n\n  gltf.images.push({\n    name: imageName,\n    extras: {\n      _obj2gltf: texture,\n    },\n  });\n\n  gltf.textures.push({\n    name: textureName,\n    sampler: 0,\n    source: imageIndex,\n  });\n\n  return textureIndex;\n}\n\nfunction getTexture(gltf, texture) {\n  let textureIndex;\n  const images = gltf.images;\n  const length = images.length;\n  for (let i = 0; i < length; ++i) {\n    if (images[i].extras._obj2gltf === texture) {\n      textureIndex = i;\n      break;\n    }\n  }\n\n  if (!defined(textureIndex)) {\n    textureIndex = addTexture(gltf, texture);\n  }\n\n  return {\n    index: textureIndex,\n  };\n}\n\nfunction cloneMaterial(material, removeTextures) {\n  if (typeof material !== \"object\") {\n    return material;\n  } else if (material instanceof Texture) {\n    if (removeTextures) {\n      return undefined;\n    }\n    return material;\n  } else if (Array.isArray(material)) {\n    const length = material.length;\n    const clonedArray = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      clonedArray[i] = cloneMaterial(material[i], removeTextures);\n    }\n    return clonedArray;\n  }\n  const clonedObject = {};\n  for (const name in material) {\n    if (Object.prototype.hasOwnProperty.call(material, name)) {\n      clonedObject[name] = cloneMaterial(material[name], removeTextures);\n    }\n  }\n  return clonedObject;\n}\n\nfunction resolveTextures(gltf, material) {\n  for (const name in material) {\n    if (Object.prototype.hasOwnProperty.call(material, name)) {\n      const property = material[name];\n      if (property instanceof Texture) {\n        material[name] = getTexture(gltf, property);\n      } else if (!Array.isArray(property) && typeof property === \"object\") {\n        resolveTextures(gltf, property);\n      }\n    }\n  }\n}\n\nfunction addGltfMaterial(gltf, material, options) {\n  resolveTextures(gltf, material);\n  const materialIndex = gltf.materials.length;\n  if (options.unlit) {\n    if (!defined(material.extensions)) {\n      material.extensions = {};\n    }\n    material.extensions.KHR_materials_unlit = {};\n  }\n  gltf.materials.push(material);\n  return materialIndex;\n}\n\nfunction getMaterialByName(materials, materialName) {\n  const materialsLength = materials.length;\n  for (let i = 0; i < materialsLength; ++i) {\n    if (materials[i].name === materialName) {\n      return materials[i];\n    }\n  }\n}\n\nfunction getMaterialIndex(materials, materialName) {\n  const materialsLength = materials.length;\n  for (let i = 0; i < materialsLength; ++i) {\n    if (materials[i].name === materialName) {\n      return i;\n    }\n  }\n}\n\nfunction getOrCreateGltfMaterial(gltf, materials, materialName, options) {\n  const material = getMaterialByName(materials, materialName);\n  let materialIndex = getMaterialIndex(gltf.materials, materialName);\n\n  if (!defined(materialIndex)) {\n    materialIndex = addGltfMaterial(gltf, material, options);\n  }\n\n  return materialIndex;\n}\n\nfunction primitiveInfoMatch(a, b) {\n  return a.hasUvs === b.hasUvs && a.hasNormals === b.hasNormals;\n}\n\nfunction getSplitMaterialName(\n  originalMaterialName,\n  primitiveInfo,\n  primitiveInfoByMaterial\n) {\n  let splitMaterialName = originalMaterialName;\n  let suffix = 2;\n  while (defined(primitiveInfoByMaterial[splitMaterialName])) {\n    if (\n      primitiveInfoMatch(\n        primitiveInfo,\n        primitiveInfoByMaterial[splitMaterialName]\n      )\n    ) {\n      break;\n    }\n    splitMaterialName = `${originalMaterialName}-${suffix++}`;\n  }\n  return splitMaterialName;\n}\n\nfunction splitIncompatibleMaterials(nodes, materials, options) {\n  const splitMaterials = [];\n  const primitiveInfoByMaterial = {};\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const meshes = nodes[i].meshes;\n    const meshesLength = meshes.length;\n    for (let j = 0; j < meshesLength; ++j) {\n      const primitives = meshes[j].primitives;\n      const primitivesLength = primitives.length;\n      for (let k = 0; k < primitivesLength; ++k) {\n        const primitive = primitives[k];\n        const hasUvs = primitive.uvs.length > 0;\n        const hasNormals = primitive.normals.length > 0;\n        const primitiveInfo = {\n          hasUvs: hasUvs,\n          hasNormals: hasNormals,\n        };\n        const originalMaterialName = defaultValue(\n          primitive.material,\n          \"default\"\n        );\n        const splitMaterialName = getSplitMaterialName(\n          originalMaterialName,\n          primitiveInfo,\n          primitiveInfoByMaterial\n        );\n        primitive.material = splitMaterialName;\n        primitiveInfoByMaterial[splitMaterialName] = primitiveInfo;\n\n        let splitMaterial = getMaterialByName(\n          splitMaterials,\n          splitMaterialName\n        );\n        if (defined(splitMaterial)) {\n          continue;\n        }\n\n        const originalMaterial = getMaterialByName(\n          materials,\n          originalMaterialName\n        );\n        if (defined(originalMaterial)) {\n          splitMaterial = cloneMaterial(originalMaterial, !hasUvs);\n        } else {\n          splitMaterial = getDefaultMaterial(options);\n        }\n        splitMaterial.name = splitMaterialName;\n        splitMaterials.push(splitMaterial);\n      }\n    }\n  }\n  return splitMaterials;\n}\n\nfunction addVertexAttribute(gltf, array, components, name) {\n  const count = array.length / components;\n  const minMax = array.getMinMax(components);\n  const type = components === 3 ? \"VEC3\" : \"VEC2\";\n\n  const accessor = {\n    name: name,\n    componentType: WebGLConstants.FLOAT,\n    count: count,\n    min: minMax.min,\n    max: minMax.max,\n    type: type,\n  };\n\n  const accessorIndex = gltf.accessors.length;\n  gltf.accessors.push(accessor);\n  return accessorIndex;\n}\n\nfunction addIndexArray(gltf, array, uint32Indices, name) {\n  const componentType = uint32Indices\n    ? WebGLConstants.UNSIGNED_INT\n    : WebGLConstants.UNSIGNED_SHORT;\n  const count = array.length;\n  const minMax = array.getMinMax(1);\n\n  const accessor = {\n    name: name,\n    componentType: componentType,\n    count: count,\n    min: minMax.min,\n    max: minMax.max,\n    type: \"SCALAR\",\n  };\n\n  const accessorIndex = gltf.accessors.length;\n  gltf.accessors.push(accessor);\n  return accessorIndex;\n}\n\nfunction requiresUint32Indices(nodes) {\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const meshes = nodes[i].meshes;\n    const meshesLength = meshes.length;\n    for (let j = 0; j < meshesLength; ++j) {\n      const primitives = meshes[j].primitives;\n      const primitivesLength = primitives.length;\n      for (let k = 0; k < primitivesLength; ++k) {\n        // Reserve the 65535 index for primitive restart\n        const vertexCount = primitives[k].positions.length / 3;\n        if (vertexCount > 65534) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction addPrimitive(\n  gltf,\n  materials,\n  bufferState,\n  uint32Indices,\n  mesh,\n  primitive,\n  index,\n  options\n) {\n  const hasPositions = primitive.positions.length > 0;\n  const hasNormals = primitive.normals.length > 0;\n  const hasUVs = primitive.uvs.length > 0;\n\n  const attributes = {};\n  if (hasPositions) {\n    const accessorIndex = addVertexAttribute(\n      gltf,\n      primitive.positions,\n      3,\n      `${mesh.name}_${index}_positions`\n    );\n    attributes.POSITION = accessorIndex;\n    bufferState.positionBuffers.push(primitive.positions.toFloatBuffer());\n    bufferState.positionAccessors.push(accessorIndex);\n  }\n  if (hasNormals) {\n    const accessorIndex = addVertexAttribute(\n      gltf,\n      primitive.normals,\n      3,\n      `${mesh.name}_${index}_normals`\n    );\n    attributes.NORMAL = accessorIndex;\n    bufferState.normalBuffers.push(primitive.normals.toFloatBuffer());\n    bufferState.normalAccessors.push(accessorIndex);\n  }\n  if (hasUVs) {\n    const accessorIndex = addVertexAttribute(\n      gltf,\n      primitive.uvs,\n      2,\n      `${mesh.name}_${index}_texcoords`\n    );\n    attributes.TEXCOORD_0 = accessorIndex;\n    bufferState.uvBuffers.push(primitive.uvs.toFloatBuffer());\n    bufferState.uvAccessors.push(accessorIndex);\n  }\n\n  const indexAccessorIndex = addIndexArray(\n    gltf,\n    primitive.indices,\n    uint32Indices,\n    `${mesh.name}_${index}_indices`\n  );\n  const indexBuffer = uint32Indices\n    ? primitive.indices.toUint32Buffer()\n    : primitive.indices.toUint16Buffer();\n  bufferState.indexBuffers.push(indexBuffer);\n  bufferState.indexAccessors.push(indexAccessorIndex);\n\n  // Unload resources\n  primitive.positions = undefined;\n  primitive.normals = undefined;\n  primitive.uvs = undefined;\n  primitive.indices = undefined;\n\n  const materialIndex = getOrCreateGltfMaterial(\n    gltf,\n    materials,\n    primitive.material,\n    options\n  );\n\n  return {\n    attributes: attributes,\n    indices: indexAccessorIndex,\n    material: materialIndex,\n    mode: WebGLConstants.TRIANGLES,\n  };\n}\n\nfunction addMesh(gltf, materials, bufferState, uint32Indices, mesh, options) {\n  const gltfPrimitives = [];\n  const primitives = mesh.primitives;\n  const primitivesLength = primitives.length;\n  for (let i = 0; i < primitivesLength; ++i) {\n    gltfPrimitives.push(\n      addPrimitive(\n        gltf,\n        materials,\n        bufferState,\n        uint32Indices,\n        mesh,\n        primitives[i],\n        i,\n        options\n      )\n    );\n  }\n\n  const gltfMesh = {\n    name: mesh.name,\n    primitives: gltfPrimitives,\n  };\n\n  const meshIndex = gltf.meshes.length;\n  gltf.meshes.push(gltfMesh);\n  return meshIndex;\n}\n\nfunction addNode(gltf, name, meshIndex, parentIndex) {\n  const node = {\n    name: name,\n    mesh: meshIndex,\n  };\n\n  const nodeIndex = gltf.nodes.length;\n  gltf.nodes.push(node);\n\n  if (defined(parentIndex)) {\n    const parentNode = gltf.nodes[parentIndex];\n    if (!defined(parentNode.children)) {\n      parentNode.children = [];\n    }\n    parentNode.children.push(nodeIndex);\n  } else {\n    gltf.scenes[gltf.scene].nodes.push(nodeIndex);\n  }\n\n  return nodeIndex;\n}\n\n// Exposed for testing\ncreateGltf._getBufferMaxByteLength = function () {\n  return BUFFER_MAX_BYTE_LENGTH;\n};\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\n\nconst ComponentDatatype = Cesium.ComponentDatatype;\n\nmodule.exports = ArrayStorage;\n\nconst initialLength = 1024; // 2^10\nconst doublingThreshold = 33554432; // 2^25 (~134 MB for a Float32Array)\nconst fixedExpansionLength = 33554432; // 2^25 (~134 MB for a Float32Array)\n\n/**\n * Provides expandable typed array storage for geometry data. This is preferable to JS arrays which are\n * stored with double precision. The resizing mechanism is similar to std::vector.\n *\n * @param {ComponentDatatype} componentDatatype The data type.\n *\n * @private\n */\nfunction ArrayStorage(componentDatatype) {\n  this.componentDatatype = componentDatatype;\n  this.typedArray = ComponentDatatype.createTypedArray(componentDatatype, 0);\n  this.length = 0;\n}\n\nfunction resize(storage, length) {\n  const typedArray = ComponentDatatype.createTypedArray(\n    storage.componentDatatype,\n    length\n  );\n  typedArray.set(storage.typedArray);\n  storage.typedArray = typedArray;\n}\n\nArrayStorage.prototype.push = function (value) {\n  const length = this.length;\n  const typedArrayLength = this.typedArray.length;\n\n  if (length === 0) {\n    resize(this, initialLength);\n  } else if (length === typedArrayLength) {\n    if (length < doublingThreshold) {\n      resize(this, typedArrayLength * 2);\n    } else {\n      resize(this, typedArrayLength + fixedExpansionLength);\n    }\n  }\n\n  this.typedArray[this.length++] = value;\n};\n\nArrayStorage.prototype.get = function (index) {\n  return this.typedArray[index];\n};\n\nconst sizeOfUint16 = 2;\nconst sizeOfUint32 = 4;\nconst sizeOfFloat = 4;\n\nArrayStorage.prototype.toUint16Buffer = function () {\n  const length = this.length;\n  const typedArray = this.typedArray;\n  const paddedLength = length + (length % 2 === 0 ? 0 : 1); // Round to next multiple of 2\n  const buffer = Buffer.alloc(paddedLength * sizeOfUint16);\n  for (let i = 0; i < length; ++i) {\n    buffer.writeUInt16LE(typedArray[i], i * sizeOfUint16);\n  }\n  return buffer;\n};\n\nArrayStorage.prototype.toUint32Buffer = function () {\n  const length = this.length;\n  const typedArray = this.typedArray;\n  const buffer = Buffer.alloc(length * sizeOfUint32);\n  for (let i = 0; i < length; ++i) {\n    buffer.writeUInt32LE(typedArray[i], i * sizeOfUint32);\n  }\n  return buffer;\n};\n\nArrayStorage.prototype.toFloatBuffer = function () {\n  const length = this.length;\n  const typedArray = this.typedArray;\n  const buffer = Buffer.alloc(length * sizeOfFloat);\n  for (let i = 0; i < length; ++i) {\n    buffer.writeFloatLE(typedArray[i], i * sizeOfFloat);\n  }\n  return buffer;\n};\n\nArrayStorage.prototype.getMinMax = function (components) {\n  const length = this.length;\n  const typedArray = this.typedArray;\n  const count = length / components;\n  const min = new Array(components).fill(Number.POSITIVE_INFINITY);\n  const max = new Array(components).fill(Number.NEGATIVE_INFINITY);\n  for (let i = 0; i < count; ++i) {\n    for (let j = 0; j < components; ++j) {\n      const index = i * components + j;\n      const value = typedArray[index];\n      min[j] = Math.min(min[j], value);\n      max[j] = Math.max(max[j], value);\n    }\n  }\n  return {\n    min: min,\n    max: max,\n  };\n};\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst path = require(\"path\");\nconst Promise = require(\"bluebird\");\n\nconst ArrayStorage = require(\"./ArrayStorage\");\nconst loadMtl = require(\"./loadMtl\");\nconst outsideDirectory = require(\"./outsideDirectory\");\nconst readLines = require(\"./readLines\");\n\nconst Axis = Cesium.Axis;\nconst Cartesian3 = Cesium.Cartesian3;\nconst ComponentDatatype = Cesium.ComponentDatatype;\nconst CoplanarPolygonGeometryLibrary = Cesium.CoplanarPolygonGeometryLibrary;\nconst defaultValue = Cesium.defaultValue;\nconst defined = Cesium.defined;\nconst PolygonPipeline = Cesium.PolygonPipeline;\nconst RuntimeError = Cesium.RuntimeError;\nconst WindingOrder = Cesium.WindingOrder;\nconst Matrix4 = Cesium.Matrix4;\n\nmodule.exports = loadObj;\n\n// Object name (o) -> node\n// Group name (g) -> mesh\n// Material name (usemtl) -> primitive\n\nfunction Node() {\n  this.name = undefined;\n  this.meshes = [];\n}\n\nfunction Mesh() {\n  this.name = undefined;\n  this.primitives = [];\n}\n\nfunction Primitive() {\n  this.material = undefined;\n  this.indices = new ArrayStorage(ComponentDatatype.UNSIGNED_INT);\n  this.positions = new ArrayStorage(ComponentDatatype.FLOAT);\n  this.normals = new ArrayStorage(ComponentDatatype.FLOAT);\n  this.uvs = new ArrayStorage(ComponentDatatype.FLOAT);\n}\n\n// OBJ regex patterns are modified from ThreeJS (https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/OBJLoader.js)\nconst vertexPattern =\n  /v(\\s+[\\d|\\.|\\+|\\-|e|E]+)(\\s+[\\d|\\.|\\+|\\-|e|E]+)(\\s+[\\d|\\.|\\+|\\-|e|E]+)/; // v float float float\nconst normalPattern =\n  /vn(\\s+[\\d|\\.|\\+|\\-|e|E]+)(\\s+[\\d|\\.|\\+|\\-|e|E]+)(\\s+[\\d|\\.|\\+|\\-|e|E]+)/; // vn float float float\nconst uvPattern = /vt(\\s+[\\d|\\.|\\+|\\-|e|E]+)(\\s+[\\d|\\.|\\+|\\-|e|E]+)/; // vt float float\nconst facePattern = /(-?\\d+)\\/?(-?\\d*)\\/?(-?\\d*)/g; // for any face format \"f v\", \"f v/v\", \"f v//v\", \"f v/v/v\"\n\nconst scratchCartesian = new Cartesian3();\n\n/**\n * Parse an obj file.\n *\n * @param {String} objPath Path to the obj file.\n * @param {Object} options The options object passed along from lib/obj2gltf.js\n * @returns {Promise} A promise resolving to the obj data, which includes an array of nodes containing geometry information and an array of materials.\n *\n * @private\n */\nfunction loadObj(objPath, options) {\n  const axisTransform = getAxisTransform(\n    options.inputUpAxis,\n    options.outputUpAxis\n  );\n\n  // Global store of vertex attributes listed in the obj file\n  let globalPositions = new ArrayStorage(ComponentDatatype.FLOAT);\n  let globalNormals = new ArrayStorage(ComponentDatatype.FLOAT);\n  let globalUvs = new ArrayStorage(ComponentDatatype.FLOAT);\n\n  // The current node, mesh, and primitive\n  let node;\n  let mesh;\n  let primitive;\n  let activeMaterial;\n\n  // All nodes seen in the obj\n  const nodes = [];\n\n  // Used to build the indices. The vertex cache is unique to each primitive.\n  let vertexCache = {};\n  const vertexCacheLimit = 1000000;\n  let vertexCacheCount = 0;\n  let vertexCount = 0;\n\n  // All mtl paths seen in the obj\n  let mtlPaths = [];\n\n  // Buffers for face data that spans multiple lines\n  let lineBuffer = \"\";\n\n  // Used for parsing face data\n  const faceVertices = [];\n  const facePositions = [];\n  const faceUvs = [];\n  const faceNormals = [];\n\n  function clearVertexCache() {\n    vertexCache = {};\n    vertexCacheCount = 0;\n  }\n\n  function getName(name) {\n    return name === \"\" ? undefined : name;\n  }\n\n  function addNode(name) {\n    node = new Node();\n    node.name = getName(name);\n    nodes.push(node);\n    addMesh();\n  }\n\n  function addMesh(name) {\n    mesh = new Mesh();\n    mesh.name = getName(name);\n    node.meshes.push(mesh);\n    addPrimitive();\n  }\n\n  function addPrimitive() {\n    primitive = new Primitive();\n    primitive.material = activeMaterial;\n    mesh.primitives.push(primitive);\n\n    // Clear the vertex cache for each new primitive\n    clearVertexCache();\n    vertexCount = 0;\n  }\n\n  function reusePrimitive(callback) {\n    const primitives = mesh.primitives;\n    const primitivesLength = primitives.length;\n    for (let i = 0; i < primitivesLength; ++i) {\n      if (primitives[i].material === activeMaterial) {\n        if (!defined(callback) || callback(primitives[i])) {\n          primitive = primitives[i];\n          clearVertexCache();\n          vertexCount = primitive.positions.length / 3;\n          return;\n        }\n      }\n    }\n    addPrimitive();\n  }\n\n  function useMaterial(name) {\n    activeMaterial = getName(name);\n    reusePrimitive();\n  }\n\n  function faceAndPrimitiveMatch(uvs, normals, primitive) {\n    const faceHasUvs = defined(uvs[0]);\n    const faceHasNormals = defined(normals[0]);\n    const primitiveHasUvs = primitive.uvs.length > 0;\n    const primitiveHasNormals = primitive.normals.length > 0;\n    return (\n      primitiveHasUvs === faceHasUvs && primitiveHasNormals === faceHasNormals\n    );\n  }\n\n  function checkPrimitive(uvs, normals) {\n    const firstFace = primitive.indices.length === 0;\n    if (!firstFace && !faceAndPrimitiveMatch(uvs, normals, primitive)) {\n      reusePrimitive(function (primitive) {\n        return faceAndPrimitiveMatch(uvs, normals, primitive);\n      });\n    }\n  }\n\n  function getIndexFromStart(index, attributeData, components) {\n    const i = parseInt(index);\n    if (i < 0) {\n      // Negative vertex indexes reference the vertices immediately above it\n      return attributeData.length / components + i;\n    }\n    return i - 1;\n  }\n\n  function correctAttributeIndices(\n    attributeIndices,\n    attributeData,\n    components\n  ) {\n    const length = attributeIndices.length;\n    for (let i = 0; i < length; ++i) {\n      if (attributeIndices[i].length === 0) {\n        attributeIndices[i] = undefined;\n      } else {\n        attributeIndices[i] = getIndexFromStart(\n          attributeIndices[i],\n          attributeData,\n          components\n        );\n      }\n    }\n  }\n\n  function correctVertices(vertices, positions, uvs, normals) {\n    const length = vertices.length;\n    for (let i = 0; i < length; ++i) {\n      vertices[i] = `${defaultValue(positions[i], \"\")}/${defaultValue(\n        uvs[i],\n        \"\"\n      )}/${defaultValue(normals[i], \"\")}`;\n    }\n  }\n\n  function createVertex(p, u, n) {\n    // Positions\n    if (defined(p) && globalPositions.length > 0) {\n      if (p * 3 >= globalPositions.length) {\n        throw new RuntimeError(`Position index ${p} is out of bounds`);\n      }\n      const px = globalPositions.get(p * 3);\n      const py = globalPositions.get(p * 3 + 1);\n      const pz = globalPositions.get(p * 3 + 2);\n      primitive.positions.push(px);\n      primitive.positions.push(py);\n      primitive.positions.push(pz);\n    }\n\n    // Normals\n    if (defined(n) && globalNormals.length > 0) {\n      if (n * 3 >= globalNormals.length) {\n        throw new RuntimeError(`Normal index ${n} is out of bounds`);\n      }\n      const nx = globalNormals.get(n * 3);\n      const ny = globalNormals.get(n * 3 + 1);\n      const nz = globalNormals.get(n * 3 + 2);\n      primitive.normals.push(nx);\n      primitive.normals.push(ny);\n      primitive.normals.push(nz);\n    }\n\n    // UVs\n    if (defined(u) && globalUvs.length > 0) {\n      if (u * 2 >= globalUvs.length) {\n        throw new RuntimeError(`UV index ${u} is out of bounds`);\n      }\n      const ux = globalUvs.get(u * 2);\n      const uy = globalUvs.get(u * 2 + 1);\n      primitive.uvs.push(ux);\n      primitive.uvs.push(uy);\n    }\n  }\n\n  function addVertex(v, p, u, n) {\n    let index = vertexCache[v];\n    if (!defined(index)) {\n      index = vertexCount++;\n      vertexCache[v] = index;\n      createVertex(p, u, n);\n\n      // Prevent the vertex cache from growing too large. As a result of clearing the cache there\n      // may be some duplicate vertices.\n      vertexCacheCount++;\n      if (vertexCacheCount > vertexCacheLimit) {\n        clearVertexCache();\n      }\n    }\n    return index;\n  }\n\n  function getPosition(index, result) {\n    const px = globalPositions.get(index * 3);\n    const py = globalPositions.get(index * 3 + 1);\n    const pz = globalPositions.get(index * 3 + 2);\n    return Cartesian3.fromElements(px, py, pz, result);\n  }\n\n  function getNormal(index, result) {\n    const nx = globalNormals.get(index * 3);\n    const ny = globalNormals.get(index * 3 + 1);\n    const nz = globalNormals.get(index * 3 + 2);\n    return Cartesian3.fromElements(nx, ny, nz, result);\n  }\n\n  const scratch1 = new Cartesian3();\n  const scratch2 = new Cartesian3();\n  const scratch3 = new Cartesian3();\n  const scratch4 = new Cartesian3();\n  const scratch5 = new Cartesian3();\n  const scratchCenter = new Cartesian3();\n  const scratchAxis1 = new Cartesian3();\n  const scratchAxis2 = new Cartesian3();\n  const scratchNormal = new Cartesian3();\n  const scratchPositions = [\n    new Cartesian3(),\n    new Cartesian3(),\n    new Cartesian3(),\n    new Cartesian3(),\n  ];\n  const scratchVertexIndices = [];\n  const scratchPoints = [];\n\n  function checkWindingCorrect(\n    positionIndex1,\n    positionIndex2,\n    positionIndex3,\n    normalIndex\n  ) {\n    if (!defined(normalIndex)) {\n      // If no face normal, we have to assume the winding is correct.\n      return true;\n    }\n    const normal = getNormal(normalIndex, scratchNormal);\n    const A = getPosition(positionIndex1, scratch1);\n    const B = getPosition(positionIndex2, scratch2);\n    const C = getPosition(positionIndex3, scratch3);\n\n    const BA = Cartesian3.subtract(B, A, scratch4);\n    const CA = Cartesian3.subtract(C, A, scratch5);\n    const cross = Cartesian3.cross(BA, CA, scratch3);\n\n    return Cartesian3.dot(normal, cross) >= 0;\n  }\n\n  function addTriangle(index1, index2, index3, correctWinding) {\n    if (correctWinding) {\n      primitive.indices.push(index1);\n      primitive.indices.push(index2);\n      primitive.indices.push(index3);\n    } else {\n      primitive.indices.push(index1);\n      primitive.indices.push(index3);\n      primitive.indices.push(index2);\n    }\n  }\n\n  function addFace(\n    vertices,\n    positions,\n    uvs,\n    normals,\n    triangleWindingOrderSanitization\n  ) {\n    correctAttributeIndices(positions, globalPositions, 3);\n    correctAttributeIndices(normals, globalNormals, 3);\n    correctAttributeIndices(uvs, globalUvs, 2);\n    correctVertices(vertices, positions, uvs, normals);\n\n    checkPrimitive(uvs, faceNormals);\n\n    if (vertices.length === 3) {\n      const isWindingCorrect =\n        !triangleWindingOrderSanitization ||\n        checkWindingCorrect(\n          positions[0],\n          positions[1],\n          positions[2],\n          normals[0]\n        );\n      const index1 = addVertex(vertices[0], positions[0], uvs[0], normals[0]);\n      const index2 = addVertex(vertices[1], positions[1], uvs[1], normals[1]);\n      const index3 = addVertex(vertices[2], positions[2], uvs[2], normals[2]);\n      addTriangle(index1, index2, index3, isWindingCorrect);\n    } else {\n      // Triangulate if the face is not a triangle\n      const points = scratchPoints;\n      const vertexIndices = scratchVertexIndices;\n\n      points.length = 0;\n      vertexIndices.length = 0;\n\n      for (let i = 0; i < vertices.length; ++i) {\n        const index = addVertex(vertices[i], positions[i], uvs[i], normals[i]);\n        vertexIndices.push(index);\n        if (i === scratchPositions.length) {\n          scratchPositions.push(new Cartesian3());\n        }\n        points.push(getPosition(positions[i], scratchPositions[i]));\n      }\n\n      const validGeometry =\n        CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(\n          points,\n          scratchCenter,\n          scratchAxis1,\n          scratchAxis2\n        );\n      if (!validGeometry) {\n        return;\n      }\n      const projectPoints =\n        CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(\n          scratchCenter,\n          scratchAxis1,\n          scratchAxis2\n        );\n      const points2D = projectPoints(points);\n      const indices = PolygonPipeline.triangulate(points2D);\n      const isWindingCorrect =\n        PolygonPipeline.computeWindingOrder2D(points2D) !==\n        WindingOrder.CLOCKWISE;\n\n      for (let i = 0; i < indices.length - 2; i += 3) {\n        addTriangle(\n          vertexIndices[indices[i]],\n          vertexIndices[indices[i + 1]],\n          vertexIndices[indices[i + 2]],\n          isWindingCorrect\n        );\n      }\n    }\n  }\n\n  function parseLine(line) {\n    line = line.trim();\n    let result;\n\n    if (line.length === 0 || line.charAt(0) === \"#\") {\n      // Don't process empty lines or comments\n    } else if (/^o\\s/i.test(line)) {\n      const objectName = line.substring(2).trim();\n      addNode(objectName);\n    } else if (/^g\\s/i.test(line)) {\n      const groupName = line.substring(2).trim();\n      addMesh(groupName);\n    } else if (/^usemtl/i.test(line)) {\n      const materialName = line.substring(7).trim();\n      useMaterial(materialName);\n    } else if (/^mtllib/i.test(line)) {\n      const mtllibLine = line.substring(7).trim();\n      mtlPaths = mtlPaths.concat(getMtlPaths(mtllibLine));\n    } else if ((result = vertexPattern.exec(line)) !== null) {\n      const position = scratchCartesian;\n      position.x = parseFloat(result[1]);\n      position.y = parseFloat(result[2]);\n      position.z = parseFloat(result[3]);\n      if (defined(axisTransform)) {\n        Matrix4.multiplyByPoint(axisTransform, position, position);\n      }\n      globalPositions.push(position.x);\n      globalPositions.push(position.y);\n      globalPositions.push(position.z);\n    } else if ((result = normalPattern.exec(line)) !== null) {\n      const normal = Cartesian3.fromElements(\n        parseFloat(result[1]),\n        parseFloat(result[2]),\n        parseFloat(result[3]),\n        scratchNormal\n      );\n      if (Cartesian3.equals(normal, Cartesian3.ZERO)) {\n        Cartesian3.clone(Cartesian3.UNIT_Z, normal);\n      } else {\n        Cartesian3.normalize(normal, normal);\n      }\n      if (defined(axisTransform)) {\n        Matrix4.multiplyByPointAsVector(axisTransform, normal, normal);\n      }\n      globalNormals.push(normal.x);\n      globalNormals.push(normal.y);\n      globalNormals.push(normal.z);\n    } else if ((result = uvPattern.exec(line)) !== null) {\n      globalUvs.push(parseFloat(result[1]));\n      globalUvs.push(1.0 - parseFloat(result[2])); // Flip y so 0.0 is the bottom of the image\n    } else {\n      // face line or invalid line\n      // Because face lines can contain n vertices, we use a line buffer in case the face data spans multiple lines.\n      // If there's a line continuation don't create face yet\n      if (line.slice(-1) === \"\\\\\") {\n        lineBuffer += line.substring(0, line.length - 1);\n        return;\n      }\n      lineBuffer += line;\n      if (lineBuffer.substring(0, 2) === \"f \") {\n        while ((result = facePattern.exec(lineBuffer)) !== null) {\n          faceVertices.push(result[0]);\n          facePositions.push(result[1]);\n          faceUvs.push(result[2]);\n          faceNormals.push(result[3]);\n        }\n        if (faceVertices.length > 2) {\n          addFace(\n            faceVertices,\n            facePositions,\n            faceUvs,\n            faceNormals,\n            options.triangleWindingOrderSanitization\n          );\n        }\n\n        faceVertices.length = 0;\n        facePositions.length = 0;\n        faceNormals.length = 0;\n        faceUvs.length = 0;\n      }\n      lineBuffer = \"\";\n    }\n  }\n\n  // Create a default node in case there are no o/g/usemtl lines in the obj\n  addNode();\n\n  // Parse the obj file\n  return readLines(objPath, parseLine).then(function () {\n    // Unload resources\n    globalPositions = undefined;\n    globalNormals = undefined;\n    globalUvs = undefined;\n\n    // Load materials and textures\n    return finishLoading(\n      nodes,\n      mtlPaths,\n      objPath,\n      defined(activeMaterial),\n      options\n    );\n  });\n}\n\nfunction getMtlPaths(mtllibLine) {\n  // Handle paths with spaces. E.g. mtllib my material file.mtl\n  const mtlPaths = [];\n  const splits = mtllibLine.split(\" \");\n  const length = splits.length;\n  let startIndex = 0;\n  for (let i = 0; i < length; ++i) {\n    if (path.extname(splits[i]) !== \".mtl\") {\n      continue;\n    }\n    const mtlPath = splits.slice(startIndex, i + 1).join(\" \");\n    mtlPaths.push(mtlPath);\n    startIndex = i + 1;\n  }\n  return mtlPaths;\n}\n\nfunction finishLoading(nodes, mtlPaths, objPath, usesMaterials, options) {\n  nodes = cleanNodes(nodes);\n  if (nodes.length === 0) {\n    throw new RuntimeError(`${objPath} does not have any geometry data`);\n  }\n  const name = path.basename(objPath, path.extname(objPath));\n  return loadMtls(mtlPaths, objPath, options).then(function (materials) {\n    if (materials.length > 0 && !usesMaterials) {\n      assignDefaultMaterial(nodes, materials, usesMaterials);\n    }\n    assignUnnamedMaterial(nodes, materials);\n    return {\n      nodes: nodes,\n      materials: materials,\n      name: name,\n    };\n  });\n}\n\nfunction normalizeMtlPath(mtlPath, objDirectory) {\n  mtlPath = mtlPath.replace(/\\\\/g, \"/\");\n  return path.normalize(path.resolve(objDirectory, mtlPath));\n}\n\nfunction loadMtls(mtlPaths, objPath, options) {\n  const objDirectory = path.dirname(objPath);\n  let materials = [];\n\n  // Remove duplicates\n  mtlPaths = mtlPaths.filter(function (value, index, self) {\n    return self.indexOf(value) === index;\n  });\n\n  return Promise.map(\n    mtlPaths,\n    function (mtlPath) {\n      mtlPath = normalizeMtlPath(mtlPath, objDirectory);\n      const shallowPath = path.join(objDirectory, path.basename(mtlPath));\n      if (options.secure && outsideDirectory(mtlPath, objDirectory)) {\n        // Try looking for the .mtl in the same directory as the obj\n        options.logger(\n          \"The material file is outside of the obj directory and the secure flag is true. Attempting to read the material file from within the obj directory instead.\"\n        );\n        return loadMtl(shallowPath, options)\n          .then(function (materialsInMtl) {\n            materials = materials.concat(materialsInMtl);\n          })\n          .catch(function (error) {\n            options.logger(error.message);\n            options.logger(\n              `Could not read material file at ${shallowPath}. Using default material instead.`\n            );\n          });\n      }\n\n      return loadMtl(mtlPath, options)\n        .catch(function (error) {\n          // Try looking for the .mtl in the same directory as the obj\n          options.logger(error.message);\n          options.logger(\n            `Could not read material file at ${mtlPath}. Attempting to read the material file from within the obj directory instead.`\n          );\n          return loadMtl(shallowPath, options);\n        })\n        .then(function (materialsInMtl) {\n          materials = materials.concat(materialsInMtl);\n        })\n        .catch(function (error) {\n          options.logger(error.message);\n          options.logger(\n            `Could not read material file at ${shallowPath}. Using default material instead.`\n          );\n        });\n    },\n    { concurrency: 10 }\n  ).then(function () {\n    return materials;\n  });\n}\n\nfunction assignDefaultMaterial(nodes, materials) {\n  const defaultMaterial = materials[0].name;\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const meshes = nodes[i].meshes;\n    const meshesLength = meshes.length;\n    for (let j = 0; j < meshesLength; ++j) {\n      const primitives = meshes[j].primitives;\n      const primitivesLength = primitives.length;\n      for (let k = 0; k < primitivesLength; ++k) {\n        const primitive = primitives[k];\n        primitive.material = defaultValue(primitive.material, defaultMaterial);\n      }\n    }\n  }\n}\n\nfunction assignUnnamedMaterial(nodes, materials) {\n  // If there is a material that doesn't have a name, assign that\n  // material to any primitives whose material is undefined.\n  const unnamedMaterial = materials.find(function (material) {\n    return material.name.length === 0;\n  });\n\n  if (!defined(unnamedMaterial)) {\n    return;\n  }\n\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const meshes = nodes[i].meshes;\n    const meshesLength = meshes.length;\n    for (let j = 0; j < meshesLength; ++j) {\n      const primitives = meshes[j].primitives;\n      const primitivesLength = primitives.length;\n      for (let k = 0; k < primitivesLength; ++k) {\n        const primitive = primitives[k];\n        if (!defined(primitive.material)) {\n          primitive.material = unnamedMaterial.name;\n        }\n      }\n    }\n  }\n}\n\nfunction removeEmptyMeshes(meshes) {\n  return meshes.filter(function (mesh) {\n    // Remove empty primitives\n    mesh.primitives = mesh.primitives.filter(function (primitive) {\n      return primitive.indices.length > 0 && primitive.positions.length > 0;\n    });\n    // Valid meshes must have at least one primitive\n    return mesh.primitives.length > 0;\n  });\n}\n\nfunction meshesHaveNames(meshes) {\n  const meshesLength = meshes.length;\n  for (let i = 0; i < meshesLength; ++i) {\n    if (defined(meshes[i].name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction removeEmptyNodes(nodes) {\n  const final = [];\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const node = nodes[i];\n    const meshes = removeEmptyMeshes(node.meshes);\n    if (meshes.length === 0) {\n      continue;\n    }\n    node.meshes = meshes;\n    if (!defined(node.name) && meshesHaveNames(meshes)) {\n      // If the obj has groups (g) but not object groups (o) then convert meshes to nodes\n      const meshesLength = meshes.length;\n      for (let j = 0; j < meshesLength; ++j) {\n        const mesh = meshes[j];\n        const convertedNode = new Node();\n        convertedNode.name = mesh.name;\n        convertedNode.meshes = [mesh];\n        final.push(convertedNode);\n      }\n    } else {\n      final.push(node);\n    }\n  }\n  return final;\n}\n\nfunction setDefaultNames(items, defaultName, usedNames) {\n  const itemsLength = items.length;\n  for (let i = 0; i < itemsLength; ++i) {\n    const item = items[i];\n    let name = defaultValue(item.name, defaultName);\n    const occurrences = usedNames[name];\n    if (defined(occurrences)) {\n      usedNames[name]++;\n      name = `${name}_${occurrences}`;\n    } else {\n      usedNames[name] = 1;\n    }\n    item.name = name;\n  }\n}\n\nfunction setDefaults(nodes) {\n  const usedNames = {};\n  setDefaultNames(nodes, \"Node\", usedNames);\n  const nodesLength = nodes.length;\n  for (let i = 0; i < nodesLength; ++i) {\n    const node = nodes[i];\n    setDefaultNames(node.meshes, `${node.name}-Mesh`, usedNames);\n  }\n}\n\nfunction cleanNodes(nodes) {\n  nodes = removeEmptyNodes(nodes);\n  setDefaults(nodes);\n  return nodes;\n}\n\nfunction getAxisTransform(inputUpAxis, outputUpAxis) {\n  if (inputUpAxis === \"X\" && outputUpAxis === \"Y\") {\n    return Axis.X_UP_TO_Y_UP;\n  } else if (inputUpAxis === \"X\" && outputUpAxis === \"Z\") {\n    return Axis.X_UP_TO_Z_UP;\n  } else if (inputUpAxis === \"Y\" && outputUpAxis === \"X\") {\n    return Axis.Y_UP_TO_X_UP;\n  } else if (inputUpAxis === \"Y\" && outputUpAxis === \"Z\") {\n    return Axis.Y_UP_TO_Z_UP;\n  } else if (inputUpAxis === \"Z\" && outputUpAxis === \"X\") {\n    return Axis.Z_UP_TO_X_UP;\n  } else if (inputUpAxis === \"Z\" && outputUpAxis === \"Y\") {\n    return Axis.Z_UP_TO_Y_UP;\n  }\n}\n", "\"use strict\";\nmodule.exports = getJsonBufferPadded;\n\n/**\n * Convert the JSON object to a padded buffer.\n *\n * Pad the JSON with extra whitespace to fit the next 4-byte boundary. This ensures proper alignment\n * for the section that follows.\n *\n * @param {Object} [json] The JSON object.\n * @returns {Buffer} The padded JSON buffer.\n *\n * @private\n */\nfunction getJsonBufferPadded(json) {\n  let string = JSON.stringify(json);\n\n  const boundary = 4;\n  const byteLength = Buffer.byteLength(string);\n  const remainder = byteLength % boundary;\n  const padding = remainder === 0 ? 0 : boundary - remainder;\n  let whitespace = \"\";\n  for (let i = 0; i < padding; ++i) {\n    whitespace += \" \";\n  }\n  string += whitespace;\n\n  return Buffer.from(string);\n}\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst getJsonBufferPadded = require(\"./getJsonBufferPadded\");\n\nconst defined = Cesium.defined;\n\nmodule.exports = gltfToGlb;\n\n/**\n * Convert a glTF to binary glTF.\n *\n * The glTF is expected to have a single buffer and all embedded resources stored in bufferViews.\n *\n * @param {Object} gltf The glTF asset.\n * @param {Buffer} binaryBuffer The binary buffer.\n * @returns {Buffer} The glb buffer.\n *\n * @private\n */\nfunction gltfToGlb(gltf, binaryBuffer) {\n  const buffer = gltf.buffers[0];\n  if (defined(buffer.uri)) {\n    binaryBuffer = Buffer.alloc(0);\n  }\n\n  // Create padded binary scene string\n  const jsonBuffer = getJsonBufferPadded(gltf);\n\n  // Allocate buffer (Global header) + (JSON chunk header) + (JSON chunk) + (Binary chunk header) + (Binary chunk)\n  const glbLength = 12 + 8 + jsonBuffer.length + 8 + binaryBuffer.length;\n  const glb = Buffer.alloc(glbLength);\n\n  // Write binary glTF header (magic, version, length)\n  let byteOffset = 0;\n  glb.writeUInt32LE(0x46546c67, byteOffset);\n  byteOffset += 4;\n  glb.writeUInt32LE(2, byteOffset);\n  byteOffset += 4;\n  glb.writeUInt32LE(glbLength, byteOffset);\n  byteOffset += 4;\n\n  // Write JSON Chunk header (length, type)\n  glb.writeUInt32LE(jsonBuffer.length, byteOffset);\n  byteOffset += 4;\n  glb.writeUInt32LE(0x4e4f534a, byteOffset); // JSON\n  byteOffset += 4;\n\n  // Write JSON Chunk\n  jsonBuffer.copy(glb, byteOffset);\n  byteOffset += jsonBuffer.length;\n\n  // Write Binary Chunk header (length, type)\n  glb.writeUInt32LE(binaryBuffer.length, byteOffset);\n  byteOffset += 4;\n  glb.writeUInt32LE(0x004e4942, byteOffset); // BIN\n  byteOffset += 4;\n\n  // Write Binary Chunk\n  binaryBuffer.copy(glb, byteOffset);\n  return glb;\n}\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst mime = require(\"mime\");\nconst PNG = require(\"pngjs\").PNG;\nconst Promise = require(\"bluebird\");\nconst getBufferPadded = require(\"./getBufferPadded\");\nconst gltfToGlb = require(\"./gltfToGlb\");\n\nconst defined = Cesium.defined;\nconst RuntimeError = Cesium.RuntimeError;\n\nmodule.exports = writeGltf;\n\n/**\n * Write glTF resources as embedded data uris or external files.\n *\n * @param {Object} gltf The glTF asset.\n * @param {Object} options The options object passed along from lib/obj2gltf.js\n * @returns {Promise} A promise that resolves to the glTF JSON or glb buffer.\n *\n * @private\n */\nfunction writeGltf(gltf, options) {\n  return encodeTextures(gltf).then(function () {\n    const binary = options.binary;\n    const separate = options.separate;\n    const separateTextures = options.separateTextures;\n\n    const promises = [];\n    if (separateTextures) {\n      promises.push(writeSeparateTextures(gltf, options));\n    } else {\n      writeEmbeddedTextures(gltf);\n    }\n\n    if (separate) {\n      promises.push(writeSeparateBuffers(gltf, options));\n    } else if (!binary) {\n      writeEmbeddedBuffer(gltf);\n    }\n\n    const binaryBuffer = gltf.buffers[0].extras._obj2gltf.source;\n\n    return Promise.all(promises).then(function () {\n      deleteExtras(gltf);\n      removeEmpty(gltf);\n      if (binary) {\n        return gltfToGlb(gltf, binaryBuffer);\n      }\n      return gltf;\n    });\n  });\n}\n\nfunction encodePng(texture) {\n  // Constants defined by pngjs\n  const rgbColorType = 2;\n  const rgbaColorType = 6;\n\n  const png = new PNG({\n    width: texture.width,\n    height: texture.height,\n    colorType: texture.transparent ? rgbaColorType : rgbColorType,\n    inputColorType: rgbaColorType,\n    inputHasAlpha: true,\n  });\n\n  png.data = texture.pixels;\n\n  return new Promise(function (resolve, reject) {\n    const chunks = [];\n    const stream = png.pack();\n    stream.on(\"data\", function (chunk) {\n      chunks.push(chunk);\n    });\n    stream.on(\"end\", function () {\n      resolve(Buffer.concat(chunks));\n    });\n    stream.on(\"error\", reject);\n  });\n}\n\nfunction encodeTexture(texture) {\n  if (\n    !defined(texture.source) &&\n    defined(texture.pixels) &&\n    texture.extension === \".png\"\n  ) {\n    return encodePng(texture).then(function (encoded) {\n      texture.source = encoded;\n    });\n  }\n}\n\nfunction encodeTextures(gltf) {\n  // Dynamically generated PBR textures need to be encoded to png prior to being saved\n  const encodePromises = [];\n  const images = gltf.images;\n  const length = images.length;\n  for (let i = 0; i < length; ++i) {\n    encodePromises.push(encodeTexture(images[i].extras._obj2gltf));\n  }\n  return Promise.all(encodePromises);\n}\n\nfunction deleteExtras(gltf) {\n  const buffers = gltf.buffers;\n  const buffersLength = buffers.length;\n  for (let i = 0; i < buffersLength; ++i) {\n    delete buffers[i].extras;\n  }\n\n  const images = gltf.images;\n  const imagesLength = images.length;\n  for (let i = 0; i < imagesLength; ++i) {\n    delete images[i].extras;\n  }\n}\n\nfunction removeEmpty(json) {\n  Object.keys(json).forEach(function (key) {\n    if (\n      !defined(json[key]) ||\n      (Array.isArray(json[key]) && json[key].length === 0)\n    ) {\n      delete json[key]; // Delete values that are undefined or []\n    } else if (typeof json[key] === \"object\") {\n      removeEmpty(json[key]);\n    }\n  });\n}\n\nfunction writeSeparateBuffers(gltf, options) {\n  const buffers = gltf.buffers;\n  return Promise.map(\n    buffers,\n    function (buffer) {\n      const source = buffer.extras._obj2gltf.source;\n      const bufferUri = `${buffer.name}.bin`;\n      buffer.uri = bufferUri;\n      return options.writer(bufferUri, source);\n    },\n    { concurrency: 10 }\n  );\n}\n\nfunction writeSeparateTextures(gltf, options) {\n  const images = gltf.images;\n  return Promise.map(\n    images,\n    function (image) {\n      const texture = image.extras._obj2gltf;\n      const imageUri = image.name + texture.extension;\n      image.uri = imageUri;\n      return options.writer(imageUri, texture.source);\n    },\n    { concurrency: 10 }\n  );\n}\n\nfunction writeEmbeddedBuffer(gltf) {\n  const buffer = gltf.buffers[0];\n  const source = buffer.extras._obj2gltf.source;\n\n  // Buffers larger than ~192MB cannot be base64 encoded due to a NodeJS limitation. Source: https://github.com/nodejs/node/issues/4266\n  if (source.length > 201326580) {\n    throw new RuntimeError(\n      \"Buffer is too large to embed in the glTF. Use the --separate flag instead.\"\n    );\n  }\n\n  buffer.uri = `data:application/octet-stream;base64,${source.toString(\n    \"base64\"\n  )}`;\n}\n\nfunction writeEmbeddedTextures(gltf) {\n  const buffer = gltf.buffers[0];\n  const bufferExtras = buffer.extras._obj2gltf;\n  const bufferSource = bufferExtras.source;\n  const images = gltf.images;\n  const imagesLength = images.length;\n  const sources = [bufferSource];\n  let byteOffset = bufferSource.length;\n\n  for (let i = 0; i < imagesLength; ++i) {\n    const image = images[i];\n    const texture = image.extras._obj2gltf;\n    const textureSource = texture.source;\n    const textureByteLength = textureSource.length;\n\n    image.mimeType = mime.getType(texture.extension);\n    image.bufferView = gltf.bufferViews.length;\n    gltf.bufferViews.push({\n      buffer: 0,\n      byteOffset: byteOffset,\n      byteLength: textureByteLength,\n    });\n    byteOffset += textureByteLength;\n    sources.push(textureSource);\n  }\n\n  const source = getBufferPadded(Buffer.concat(sources));\n  bufferExtras.source = source;\n  buffer.byteLength = source.length;\n}\n", "\"use strict\";\nconst Cesium = require(\"cesium\");\nconst fsExtra = require(\"fs-extra\");\nconst path = require(\"path\");\nconst createGltf = require(\"./createGltf\");\nconst loadObj = require(\"./loadObj\");\nconst writeGltf = require(\"./writeGltf\");\n\nconst defaultValue = Cesium.defaultValue;\nconst defined = Cesium.defined;\nconst DeveloperError = Cesium.DeveloperError;\n\nmodule.exports = obj2gltf;\n\n/**\n * Converts an obj file to a glTF or glb.\n *\n * @param {String} objPath Path to the obj file.\n * @param {Object} [options] An object with the following properties:\n * @param {Boolean} [options.binary=false] Convert to binary glTF.\n * @param {Boolean} [options.separate=false] Write out separate buffer files and textures instead of embedding them in the glTF.\n * @param {Boolean} [options.separateTextures=false] Write out separate textures only.\n * @param {Boolean} [options.checkTransparency=false] Do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.\n * @param {Boolean} [options.secure=false] Prevent the converter from reading textures or mtl files outside of the input obj directory.\n * @param {Boolean} [options.packOcclusion=false] Pack the occlusion texture in the red channel of the metallic-roughness texture.\n * @param {Boolean} [options.metallicRoughness=false] The values in the mtl file are already metallic-roughness PBR values and no conversion step should be applied. Metallic is stored in the Ks and map_Ks slots and roughness is stored in the Ns and map_Ns slots.\n * @param {Boolean} [options.specularGlossiness=false] The values in the mtl file are already specular-glossiness PBR values and no conversion step should be applied. Specular is stored in the Ks and map_Ks slots and glossiness is stored in the Ns and map_Ns slots. The glTF will be saved with the KHR_materials_pbrSpecularGlossiness extension.\n * @param {Boolean} [options.unlit=false] The glTF will be saved with the KHR_materials_unlit extension.\n * @param {Object} [options.overridingTextures] An object containing texture paths that override textures defined in the .mtl file. This is often convenient in workflows where the .mtl does not exist or is not set up to use PBR materials. Intended for models with a single material.\n * @param {String} [options.overridingTextures.metallicRoughnessOcclusionTexture] Path to the metallic-roughness-occlusion texture, where occlusion is stored in the red channel, roughness is stored in the green channel, and metallic is stored in the blue channel. The model will be saved with a pbrMetallicRoughness material.\n * @param {String} [options.overridingTextures.specularGlossinessTexture] Path to the specular-glossiness texture, where specular color is stored in the red, green, and blue channels and specular glossiness is stored in the alpha channel. The model will be saved with a material using the KHR_materials_pbrSpecularGlossiness extension.\n * @param {String} [options.overridingTextures.occlusionTexture] Path to the occlusion texture. Ignored if metallicRoughnessOcclusionTexture is also set.\n * @param {String} [options.overridingTextures.normalTexture] Path to the normal texture.\n * @param {String} [options.overridingTextures.baseColorTexture] Path to the baseColor/diffuse texture.\n * @param {String} [options.overridingTextures.emissiveTexture] Path to the emissive texture.\n * @param {String} [options.overridingTextures.alphaTexture] Path to the alpha texture.\n * @param {String} [options.inputUpAxis='Y'] Up axis of the obj. Choices are 'X', 'Y', and 'Z'.\n * @param {String} [options.outputUpAxis='Y'] Up axis of the converted glTF. Choices are 'X', 'Y', and 'Z'.\n * @param {String} [options.triangleWindingOrderSanitization=false] Apply triangle winding order sanitization.\n * @param {Logger} [options.logger] A callback function for handling logged messages. Defaults to console.log.\n * @param {Writer} [options.writer] A callback function that writes files that are saved as separate resources.\n * @param {String} [options.outputDirectory] Output directory for writing separate resources when options.writer is not defined.\n * @return {Promise} A promise that resolves to the glTF JSON or glb buffer.\n */\nfunction obj2gltf(objPath, options) {\n  const defaults = obj2gltf.defaults;\n  options = defaultValue(options, {});\n  options.binary = defaultValue(options.binary, defaults.binary);\n  options.separate = defaultValue(options.separate, defaults.separate);\n  options.separateTextures =\n    defaultValue(options.separateTextures, defaults.separateTextures) ||\n    options.separate;\n  options.checkTransparency = defaultValue(\n    options.checkTransparency,\n    defaults.checkTransparency\n  );\n  options.secure = defaultValue(options.secure, defaults.secure);\n  options.packOcclusion = defaultValue(\n    options.packOcclusion,\n    defaults.packOcclusion\n  );\n  options.metallicRoughness = defaultValue(\n    options.metallicRoughness,\n    defaults.metallicRoughness\n  );\n  options.specularGlossiness = defaultValue(\n    options.specularGlossiness,\n    defaults.specularGlossiness\n  );\n  options.unlit = defaultValue(options.unlit, defaults.unlit);\n  options.overridingTextures = defaultValue(\n    options.overridingTextures,\n    defaultValue.EMPTY_OBJECT\n  );\n  options.logger = defaultValue(options.logger, getDefaultLogger());\n  options.writer = defaultValue(\n    options.writer,\n    getDefaultWriter(options.outputDirectory)\n  );\n  options.inputUpAxis = defaultValue(options.inputUpAxis, defaults.inputUpAxis);\n  options.outputUpAxis = defaultValue(\n    options.outputUpAxis,\n    defaults.outputUpAxis\n  );\n  options.triangleWindingOrderSanitization = defaultValue(\n    options.triangleWindingOrderSanitization,\n    defaults.triangleWindingOrderSanitization\n  );\n\n  if (!defined(objPath)) {\n    throw new DeveloperError(\"objPath is required\");\n  }\n\n  if (options.separateTextures && !defined(options.writer)) {\n    throw new DeveloperError(\n      \"Either options.writer or options.outputDirectory must be defined when writing separate resources.\"\n    );\n  }\n\n  if (\n    options.metallicRoughness + options.specularGlossiness + options.unlit >\n    1\n  ) {\n    throw new DeveloperError(\n      \"Only one material type may be set from [metallicRoughness, specularGlossiness, unlit].\"\n    );\n  }\n\n  if (\n    defined(options.overridingTextures.metallicRoughnessOcclusionTexture) &&\n    defined(options.overridingTextures.specularGlossinessTexture)\n  ) {\n    throw new DeveloperError(\n      \"metallicRoughnessOcclusionTexture and specularGlossinessTexture cannot both be defined.\"\n    );\n  }\n\n  if (defined(options.overridingTextures.metallicRoughnessOcclusionTexture)) {\n    options.metallicRoughness = true;\n    options.specularGlossiness = false;\n    options.packOcclusion = true;\n  }\n\n  if (defined(options.overridingTextures.specularGlossinessTexture)) {\n    options.metallicRoughness = false;\n    options.specularGlossiness = true;\n  }\n\n  return loadObj(objPath, options)\n    .then(function (objData) {\n      return createGltf(objData, options);\n    })\n    .then(function (gltf) {\n      return writeGltf(gltf, options);\n    });\n}\n\nfunction getDefaultLogger() {\n  return function (message) {\n    console.log(message);\n  };\n}\n\nfunction getDefaultWriter(outputDirectory) {\n  if (defined(outputDirectory)) {\n    return function (file, data) {\n      const outputFile = path.join(outputDirectory, file);\n      return fsExtra.outputFile(outputFile, data);\n    };\n  }\n}\n\n/**\n * Default values that will be used when calling obj2gltf(options) unless specified in the options object.\n */\nobj2gltf.defaults = {\n  /**\n   * Gets or sets whether the converter will return a glb.\n   * @type Boolean\n   * @default false\n   */\n  binary: false,\n  /**\n   * Gets or sets whether to write out separate buffer and texture,\n   * shader files, and textures instead of embedding them in the glTF.\n   * @type Boolean\n   * @default false\n   */\n  separate: false,\n  /**\n   * Gets or sets whether to write out separate textures only.\n   * @type Boolean\n   * @default false\n   */\n  separateTextures: false,\n  /**\n   * Gets or sets whether the converter will do a more exhaustive check for texture transparency by looking at the alpha channel of each pixel.\n   * @type Boolean\n   * @default false\n   */\n  checkTransparency: false,\n  /**\n   * Gets or sets whether the source model can reference paths outside of its directory.\n   * @type Boolean\n   * @default false\n   */\n  secure: false,\n  /**\n   * Gets or sets whether to pack the occlusion texture in the red channel of the metallic-roughness texture.\n   * @type Boolean\n   * @default false\n   */\n  packOcclusion: false,\n  /**\n   * Gets or sets whether rhe values in the .mtl file are already metallic-roughness PBR values and no conversion step should be applied. Metallic is stored in the Ks and map_Ks slots and roughness is stored in the Ns and map_Ns slots.\n   * @type Boolean\n   * @default false\n   */\n  metallicRoughness: false,\n  /**\n   * Gets or sets whether the values in the .mtl file are already specular-glossiness PBR values and no conversion step should be applied. Specular is stored in the Ks and map_Ks slots and glossiness is stored in the Ns and map_Ns slots. The glTF will be saved with the KHR_materials_pbrSpecularGlossiness extension.\n   * @type Boolean\n   * @default false\n   */\n  specularGlossiness: false,\n  /**\n   * Gets or sets whether the glTF will be saved with the KHR_materials_unlit extension.\n   * @type Boolean\n   * @default false\n   */\n  unlit: false,\n  /**\n   * Gets or sets the up axis of the obj.\n   * @type String\n   * @default 'Y'\n   */\n  inputUpAxis: \"Y\",\n  /**\n   * Gets or sets the up axis of the converted glTF.\n   * @type String\n   * @default 'Y'\n   */\n  outputUpAxis: \"Y\",\n  /**\n   * Gets or sets whether triangle winding order sanitization will be applied.\n   * @type Boolean\n   * @default false\n   */\n  windingOrderSanitization: false,\n};\n\n/**\n * A callback function that logs messages.\n * @callback Logger\n *\n * @param {String} message The message to log.\n */\n\n/**\n * A callback function that writes files that are saved as separate resources.\n * @callback Writer\n *\n * @param {String} file The relative path of the file.\n * @param {Buffer} data The file data to write.\n * @returns {Promise} A promise that resolves when the file is written.\n */\n", "\"use strict\";\nmodule.exports = require(\"./lib/obj2gltf\");\n"],
  "mappings": "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",
  "names": ["Promise", "Promise", "Promise", "mtlDirectory", "material", "options", "texture", "Promise", "primitive", "Promise", "require_obj2gltf"]
}
